<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3D Reconstruction</title>
    <url>/posts/18060.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Urban-Scene-Semantic-Segmentation"><a href="#1-Urban-Scene-Semantic-Segmentation" class="headerlink" title="1 Urban-Scene-Semantic-Segmentation"></a>1 Urban-Scene-Semantic-Segmentation</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>







<h1 id="2-COLMAP"><a href="#2-COLMAP" class="headerlink" title="2 COLMAP"></a>2 COLMAP</h1>]]></content>
  </entry>
  <entry>
    <title>Blog Hexo</title>
    <url>/posts/39773.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录使用 hexo + github pages 搭建个人博客的步骤</p>
<span id="more"></span>


<h1 id="1-Hexo-搭建"><a href="#1-Hexo-搭建" class="headerlink" title="1 Hexo 搭建"></a>1 Hexo 搭建</h1><h2 id="1-1-Macbook-ClashX-终端代理"><a href="#1-1-Macbook-ClashX-终端代理" class="headerlink" title="1.1 Macbook ClashX 终端代理"></a>1.1 Macbook ClashX 终端代理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure>



<h2 id="1-2-安装-Homebrew"><a href="#1-2-安装-Homebrew" class="headerlink" title="1.2 安装 Homebrew"></a>1.2 安装 Homebrew</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-安装-node-js、git"><a href="#1-3-安装-node-js、git" class="headerlink" title="1.3 安装 node.js、git"></a>1.3 安装 node.js、git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install node git</span><br></pre></td></tr></table></figure>



<h2 id="1-4-安装-Hexo"><a href="#1-4-安装-Hexo" class="headerlink" title="1.4 安装 Hexo"></a>1.4 安装 Hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="1-5-初始化项目"><a href="#1-5-初始化项目" class="headerlink" title="1.5 初始化项目"></a>1.5 初始化项目</h2><p>在 Documents 目录下创建一个 blog 文件夹，使用 hexo 命令初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/Documents</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 hexo 编译生成 HTML 代码</span></span><br><span class="line">hexo generate  # 简化命令：hexo g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在本地运行</span></span><br><span class="line">hexo serve  # 简化命令：hexo s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装远程部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程部署</span></span><br><span class="line">hexo deploy  # 简化命令：hexo d</span><br></pre></td></tr></table></figure>



<p>远程部署到 Github Pages 需要更改根目录（~&#x2F;Documents&#x2F;blog）下的 _config.yml 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:wzq11011/wzq11011.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>



<p>这个地方会报错，需要将本地 git 公钥添加到 github 中。</p>
<h2 id="1-6-同步源码"><a href="#1-6-同步源码" class="headerlink" title="1.6 同步源码"></a>1.6 同步源码</h2><p>以上的部署只是将 blog&#x2F;public 目录下的所有内容上传到 master 分支上，它们实际上是 hexo 编译生成的静态文件。如果要同步博客源码，可以新建一个 hexo 分支，使用 git 命令同步上传所有源码。</p>
<p>Git 基本使用：<a href="https://www.runoob.com/git/git-basic-operations.html">Git 基本操作 | 菜鸟教程 (runoob.com)</a></p>
<p><img src="/./Blog-Hexo.assets/image-20230425211932942.png" alt="image-20230425211932942"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个简单的操作流程</span></span><br><span class="line">git init  # 初始化仓库</span><br><span class="line">git add .  # 添加文件到暂存区</span><br><span class="line">git commit -m &quot;描述&quot;  # 将暂存区内容添加到仓库，并添加描述</span><br><span class="line"></span><br><span class="line">git status  # 查看当前仓库状态，显示有变更的文件</span><br><span class="line">git diff  # 比较文件的不同，即暂存区和工作区的差异</span><br><span class="line">git reset  # 回退版本</span><br><span class="line">git rm  # 将文件从暂存区和工作区删除</span><br><span class="line">git mv	# 移动或重命名工作区文件</span><br><span class="line">git remote	# 查看当前的远程仓库</span><br><span class="line">git remote add  # 添加远程仓库</span><br><span class="line">git clone  # clone 一个仓库</span><br><span class="line">git pull/fetch  # 拉取仓库</span><br><span class="line">git push  # 上传本地代码到远程仓库</span><br></pre></td></tr></table></figure>



<p>Git 分支管理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git 命令</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分支</span></span><br><span class="line">git branch (branchname)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分支</span></span><br><span class="line">git branch -d (branchname)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git checkout (branchname)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并分支</span></span><br><span class="line">git merge</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">git log</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>博客源码上传参考以下指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git checkout -b hexo</span><br><span class="line">git add -A  # 添加文件到暂存区</span><br><span class="line">git commit -m &quot;init blog&quot;  # 将暂存区内容添加到本地仓库，并添加描述“初始化”</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git remote add origin git@github.com:&#123;username&#125;/&#123;username&#125;.github.io.git</span></span><br><span class="line">git remote add origin git@github.com:wzq11011/wzq11011.github.io.git  # 创建远程仓库 origin</span><br><span class="line">git push origin hexo  # 推送代码到 hexo 分支</span><br></pre></td></tr></table></figure>



<p>报错：这是因为在 themes 文件夹下使用 git 命令拉取的 next 主题，关联了其他作者的 git 仓库，所以 next 文件夹下的内容会无法提交到远程仓库，报错信息提示是否将其作为子模块提交，这里提供不作为子模块提交的解决办法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hint: You&#x27;ve added another git repository inside your current repository.</span><br><span class="line">hint: Clones of the outer repository will not contain the contents of</span><br><span class="line">hint: the embedded repository and will not know how to obtain it.</span><br><span class="line">hint: If you meant to add a submodule, use:</span><br><span class="line">hint: </span><br><span class="line">hint: 	git submodule add &lt;url&gt; themes/next</span><br><span class="line">hint: </span><br><span class="line">hint: If you added this path by mistake, you can remove it from the</span><br><span class="line">hint: index with:</span><br><span class="line">hint: </span><br><span class="line">hint: 	git rm --cached themes/next</span><br><span class="line">hint: </span><br><span class="line">hint: See &quot;git help submodule&quot; for more information.</span><br></pre></td></tr></table></figure>



<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从暂存区删除该文件夹</span></span><br><span class="line">git rm --cached themes/next</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 next 文件夹下 .git 文件夹</span></span><br><span class="line">cd themes/next</span><br><span class="line">rm -rf .git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新添加 next 文件夹到缓存区</span></span><br><span class="line">git add themes/next/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">git commit -m <span class="string">&quot;add next&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送代码到远程仓库</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>



<h2 id="1-7-多设备同步"><a href="#1-7-多设备同步" class="headerlink" title="1.7 多设备同步"></a>1.7 多设备同步</h2><p>在新设备上拉取博客源码并安装必要的插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/wzq11011/wzq11011.github.io.git</span><br><span class="line"></span><br><span class="line">cd wzq11011.github.io </span><br><span class="line"></span><br><span class="line">npm install </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后执行脚本，生成部署博客，同步源码到仓库</span></span><br><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure>



<p>如果在同步仓库时出现权限不足的问题，需要将本机公钥添加到 github 中</p>
<p>问题描述：</p>
<blockquote>
<p><a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>: Permission denied (publickey)</p>
</blockquote>
<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 验证邮箱与 github 注册邮箱是否一致</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 设置全局用户名和邮箱</span></span><br><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 生成密钥</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;your email&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4 将 rsa.pub 公钥内容添加到 github</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5 测试</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>



<h2 id="1-8-配置站点信息"><a href="#1-8-配置站点信息" class="headerlink" title="1.8 配置站点信息"></a>1.8 配置站点信息</h2><p>修改根目录下的 _config.yml 文件，在 Site 区域，自定义站点标题、副标题、描述、关键词、作者等</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">CodeCoda</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">宝剑锋从磨砺出，梅花香自苦寒来</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">wzq11011</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>  <span class="comment"># en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="1-9-修改主题"><a href="#1-9-修改主题" class="headerlink" title="1.9 修改主题"></a>1.9 修改主题</h2><p>在 Hexo 官网可以查看更多主题。</p>
<p>更改主题为 Next ，Github地址：<a href="https://github.com/theme-next/hexo-theme-next">theme-next&#x2F;hexo-theme-next: Elegant and powerful theme for Hexo. (github.com)</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以在 github 上下载压缩文件，解压到 blog/themes/ 目录下，解压后重命名为 next</span></span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改根目录下的 _config.yml 文件，找到 theme 字样，修改为 next。</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>





<h1 id="2-Hexo-优化"><a href="#2-Hexo-优化" class="headerlink" title="2 Hexo 优化"></a>2 Hexo 优化</h1><h2 id="2-1-更改主题样式"><a href="#2-1-更改主题样式" class="headerlink" title="2.1 更改主题样式"></a>2.1 更改主题样式</h2><p>在 <code>blog/themes/next/_config.yml</code> 中更改 <code>Next</code> 主题样式为 <code>Pisces</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-Favicon"><a href="#2-2-Favicon" class="headerlink" title="2.2 Favicon"></a>2.2 Favicon</h2><p>自定义站点标签栏小图标，默认使用 Hexo 小图标，可以上传图片定制小图标，下载图标保存在 themes&#x2F;next&#x2F;source&#x2F;images 目录下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment"># android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment"># ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3-Code"><a href="#2-3-Code" class="headerlink" title="2.3 Code"></a>2.3 Code</h2><p>更改代码块的颜色为黑色，并把复制按钮的样式改为类似 Mac 的样式，修改 _config.yml 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4-评论系统"><a href="#2-4-评论系统" class="headerlink" title="2.4 评论系统"></a>2.4 评论系统</h2><p>注册一个 OAuth Application，链接为 <a href="https://github.com/settings/applications/new">New OAuth Application (github.com)</a>  Homepage URL 和 Authorization callback URL 填博客主域名，拿到 Client ID、Client Secret ，然后在 _config.yml 中更改对应参数即可。</p>
<p>在 blog&#x2F;themes&#x2F;next&#x2F;_config.yml 中，补充 active 参数为 gitalk</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Multiple Comment System Support</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Available values: tabs | buttons</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">tabs</span></span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">gitalk</span></span><br><span class="line">  <span class="comment"># Setting `true` means remembering the comment system selected by the visitor.</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Lazyload all comment systems.</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Modify texts or order for any navs, here are some examples.</span></span><br><span class="line">  <span class="attr">nav:</span></span><br><span class="line">    <span class="comment">#disqus:</span></span><br><span class="line">    <span class="comment">#  text: Load Disqus</span></span><br><span class="line">    <span class="comment">#  order: -1</span></span><br><span class="line">    <span class="comment">#gitalk:</span></span><br><span class="line">    <span class="comment">#  order: -2</span></span><br></pre></td></tr></table></figure>

<p>然后再 gitalk 区域填写各项参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">wzq11011</span> <span class="comment"># </span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">wzq11011.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> &#123;<span class="string">your</span> <span class="string">client_id</span>&#125; <span class="comment"># Github Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> &#123;<span class="string">your</span> <span class="string">client_secret</span>&#125; <span class="comment"># Github Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">wzq11011</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>





<h2 id="2-5-other"><a href="#2-5-other" class="headerlink" title="2.5 other"></a>2.5 other</h2><p>top:浏览网页时，快速返回到网站上端，修改 _config.yml 的 back2top 字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>Reading_process：阅读进度，sidebar——是否显示侧栏，scrollpercent——显示阅读百分比</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reading progress bar</span></span><br><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br></pre></td></tr></table></figure>



<p>Bookmark：书签，可根据阅读历史记录，定位上次位置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bookmark Support</span></span><br><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#222&quot;</span></span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>



<p>Github_banner：github 链接</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/wzq11011</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>



<p>Pangu：中英文之间留空</p>
<p>math：数学公式显示</p>
<p>pjax：</p>
<h2 id="2-6-标签页、分类页、搜索页"><a href="#2-6-标签页、分类页、搜索页" class="headerlink" title="2.6 标签页、分类页、搜索页"></a>2.6 标签页、分类页、搜索页</h2><h1 id="3-Hexo-插件记录"><a href="#3-Hexo-插件记录" class="headerlink" title="3 Hexo 插件记录"></a>3 Hexo 插件记录</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><h2 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h2><h2 id="3-4-代码高亮"><a href="#3-4-代码高亮" class="headerlink" title="3.4 代码高亮"></a>3.4 代码高亮</h2><h2 id="3-5-在线编写"><a href="#3-5-在线编写" class="headerlink" title="3.5 在线编写"></a>3.5 在线编写</h2><p>1  <a href="http://localhost:5777/#/login">Hexo Editor</a></p>
<p>2  <a href="http://localhost:4000/admin/#/">Hexo Admin</a></p>
<h2 id="3-6-永久链接"><a href="#3-6-永久链接" class="headerlink" title="3.6 永久链接"></a>3.6 永久链接</h2><ul>
<li>安装插件 hexo-abbrlink</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>_config.yml</code>文件中的配置项（记得把原来的<code>permalink:</code>删除掉）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#设置永久链接</span><br><span class="line">permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlink</span><br><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(<span class="keyword">default</span>) and crc32</span><br><span class="line">    rep: dec     #进制： dec(<span class="keyword">default</span>) and hex</span><br></pre></td></tr></table></figure>





<h1 id="4-多终端同步"><a href="#4-多终端同步" class="headerlink" title="4 多终端同步"></a>4 多终端同步</h1><p>注意：<code>username.github.io</code> 存放的是 <code>hexo</code> 生成的静态文件，用于展示博客内容；<code>HexoBlog</code> 仓库用于存放博客源码，可设置其为私人仓库。</p>
<p>新设备只需要克隆博客源码，然后重新配置一遍 <code>hexo</code> 运行环境就可以继续写博客了。</p>
<h1 id="5-定时更新博客"><a href="#5-定时更新博客" class="headerlink" title="5 定时更新博客"></a>5 定时更新博客</h1><p><strong>目标</strong>：通过脚本定时生成博客、部署博客、同步博客源码</p>
<p><strong>工具</strong>：crontab</p>
<p><strong>介绍</strong>：<code>crontab</code> 是一个用于定期执行任务（cron jobs）的工具，它允许用户按照设定的时间间隔自动运行命令或脚本。</p>
<p><strong>示例</strong>：每天晚上12点自动更新博客</p>
<ol>
<li>创建 <code>deploy_blog.sh</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态博客文件并部署到 GitHub</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送代码到远程博客源码仓库</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;update <span class="subst">$(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span>&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>给脚本可执行权限</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x deploy_blog.sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置 Cron 作业</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户的所有 cron 作业</span></span><br><span class="line">crontab -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前命令行环境设置编辑器为 vim</span></span><br><span class="line"><span class="built_in">export</span> EDITOR=vim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 bashrc ，设置 vim 为默认编辑器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export EDITOR=vim&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑当前用户的 cron 作业</span></span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">0 0 * * * /path/to/your/deploy_blog.sh &gt;&gt; /path/to/your/deploy_log.txt 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出编辑重启 cron</span></span><br><span class="line">sudo service cron restart</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>解释：</p>
<ul>
<li><p><code>0 0 * * *</code>: 每天凌晨00:00执行。</p>
</li>
<li><p><code>/path/to/your/deploy_blog.sh</code>: 替换为你的脚本的实际路径。</p>
</li>
<li><p><code>&gt;&gt; /path/to/your/deploy_log.txt 2&gt;&amp;1</code>: 将标准输出和标准错误重定向到日志文件，方便调试。</p>
</li>
</ul>
</li>
<li><p>Crontab 时间格式：Cron 表达式由五部分组成，分别代表分钟、小时、日、月和星期几。每个部分的取值范围如下：</p>
<ul>
<li><p>分钟（0-59）</p>
</li>
<li><p>小时（0-23）</p>
</li>
<li><p>日（1-31）</p>
</li>
<li><p>月（1-12）</p>
</li>
<li><p>星期几（0-7），其中 0 和 7 都表示星期日</p>
</li>
</ul>
</li>
<li><p>例如：</p>
<ul>
<li><p><code>* * * * *</code>：每分钟执行一次。</p>
</li>
<li><p><code>0 0 * * *</code>：每天凌晨0点执行。</p>
</li>
<li><p><code>0 0 * * 1</code>：每周一凌晨0点执行。</p>
</li>
<li><p><code>*/10 * * * *</code>：每隔10分钟执行一次。</p>
</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/371995929">如何在 GitHub 上写博客？ - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://www.glwsq.cn/post/hexo-plugins/">hexo插件推荐 - 给力经验分享 (glwsq.cn)</a></p>
</li>
<li><p><a href="https://blog.shipengx.com/archives/208e6058.html">使用Hexo + GitHub Pages搭建个人博客站点 | 朝花夕拾 (shipengx.com)</a></p>
</li>
<li><p>通义千问</p>
</li>
</ol>
<p>未完待续！</p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/posts/15279.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-C"><a href="#1-C" class="headerlink" title="1 C++"></a>1 C++</h1><p>基础：变量、条件、循环、字符串、数组、函数、结构体等</p>
<p>重要：指针和内存管理</p>
<p>书籍：c++ primer</p>
<h1 id="2-数据结构与算法"><a href="#2-数据结构与算法" class="headerlink" title="2 数据结构与算法"></a>2 数据结构与算法</h1><p>大话数据结构、剑指offer、leetcode 刷题</p>
<p>常见的数据结构：字符串、链表、二叉树、堆、栈、队列、哈希等</p>
<p>常见的算法：查找、排序、动态规划等</p>
<h1 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3 操作系统"></a>3 操作系统</h1><p>进程和线程：原子性、并发、锁等</p>
<p>内存：内存分布、内存调度</p>
<h1 id="4-计算机网络"><a href="#4-计算机网络" class="headerlink" title="4 计算机网络"></a>4 计算机网络</h1><p>TCP&#x2F;IP协议栈：ARP协议、IP协议、ICMP协议、TCP协议、UDP协议、DNS协议、HTTP&#x2F;HTTPS协议</p>
<p>书籍：tcp&#x2F;ip详解</p>
<h1 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5 设计模式"></a>5 设计模式</h1><p>单例、工厂、代理、策略、模板方法</p>
<p>书籍：《大话设计模式》</p>
<h1 id="5-实践"><a href="#5-实践" class="headerlink" title="5 实践"></a>5 实践</h1><ul>
<li><p>Linux操作系统、shell编程、脚本</p>
</li>
<li><p>编译、调试工具： GNU官方关于gcc和gdb的官方文档。《跟我一起写makefile》  gdb调试《debugging with gdb》</p>
</li>
<li><p>Linux系统编程、多线程编程（线程、资源、信号、同步、互斥、锁等）、 网络编程</p>
</li>
</ul>
<p>书籍：</p>
<h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><p>b站：程序羊</p>
]]></content>
  </entry>
  <entry>
    <title>Java常用知识</title>
    <url>/posts/34181.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><p><code>char</code>是Java的基本数据类型之一，用来表示单个字符。每个<code>char</code>变量占用16位（2字节），可以存储一个Unicode字符 </p>
<h3 id="创建-char"><a href="#创建-char" class="headerlink" title="创建 char"></a>创建 <code>char</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 单引号内必须是单个字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="number">65</span>;  <span class="comment">// 使用ASCII值也可以创建字符，这里会显示&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul>
<li><p>算术运算：由于<code>char</code>实际上是一个整数类型的别名，所以可以直接参与算术运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">char</span>)(a + <span class="number">1</span>); <span class="comment">// 结果为&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>比较：可以使用<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>等进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isGreater</span> <span class="operator">=</span> (<span class="string">&#x27;d&#x27;</span> &gt; <span class="string">&#x27;b&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="与-String-的联系和区别"><a href="#与-String-的联系和区别" class="headerlink" title="与 String 的联系和区别"></a>与 String 的联系和区别</h3><ul>
<li><p><strong>相互转换</strong>：可以通过多种方式进行<code>char</code>和<code>String</code>之间的转换</p>
<ul>
<li><p>将<code>String</code>转换为<code>char</code>数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] chars = str.toCharArray(); <span class="comment">// 返回包含所有字符的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>char</code>转换为<code>String</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strFromChar</span> <span class="operator">=</span> Character.toString(ch); <span class="comment">// 或者String.valueOf(ch)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>区别</strong></p>
<ul>
<li><p><strong>基本 vs 引用类型</strong>：<code>char</code>是基本数据类型，而<code>String</code>是一个引用类型。</p>
</li>
<li><p><strong>不变性</strong>：<code>String</code>对象是不可变的，而<code>char</code>是可变的。</p>
</li>
<li><p><strong>内存管理</strong>：<code>String</code>对象通常存储在堆上，而<code>char</code>直接存储其值。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在Java中，<code>Character</code>类是位于<code>java.lang</code>包中的一个包装类（wrapper class），它提供了对基本数据类型<code>char</code>的封装，并提供了一系列静态方法来操作字符。<code>Character</code>类的对象包含一个类型为<code>char</code>的单个字段，使得基本数据类型能够作为对象进行处理。</p>
<p><code>Character</code>类的主要用途是对单个字符进行操作，例如检查字符是否为字母、数字、转换大小写等。以下是<code>Character</code>类的一些基础概念和用法：</p>
<h3 id="创建-Character-对象"><a href="#创建-Character-对象" class="headerlink" title="创建 Character 对象"></a>创建 Character 对象</h3><p>尽管在Java中可以使用自动装箱（autoboxing）将<code>char</code>类型的值直接赋给<code>Character</code>对象，但也可以显式地通过构造函数创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>然而，由于自动装箱的存在，通常不需要这样做，可以直接写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>





<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>在Java中，<code>String</code>是不可变的类，这意味着一旦创建了一个<code>String</code>对象，它的值就不能改变。所有对字符串的操作都会返回一个新的<code>String</code>对象。 （引用类型）</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><code>length()</code>：获取字符串长度</li>
<li><code>charAt(int index)</code>：获取指定位置的字符</li>
<li><code>substring(int beginIndex, int endIndex)</code>：获取子串</li>
<li><code>equals(Object anObject)</code>：比较两个字符串是否相等</li>
<li><code>toLowerCase()</code> 和 <code>toUpperCase()</code>：转换大小写</li>
<li><code>trim()</code>：去除首尾空白字符</li>
<li><code>replace(char oldChar, char newChar)</code>：替换字符</li>
<li><code>split(String regex)</code>：根据正则表达式分割字符串</li>
<li><code>concat(String str)</code>：连接字符串</li>
<li><code>indexOf(int ch)</code> 和 <code>lastIndexOf(int ch)</code> 查找字符或子串的位置</li>
</ul>
<h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>由于<code>String</code>对象是不可变的，在进行修改操作时会生成新的<code>String</code>对象。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>通义千问</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>voldor-imu</title>
    <url>/posts/11821.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>VOLDOR-SLAM: For the times when feature-based or direct methods are not good enough (ICRA 2021)</p>
<h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h1><h2 id="1-1-VOLDOR-SLAM"><a href="#1-1-VOLDOR-SLAM" class="headerlink" title="1.1 VOLDOR-SLAM"></a>1.1 VOLDOR-SLAM</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">env</span></span></span><br><span class="line">conda create -n voldor python==3.6.9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">activate</span></span><br><span class="line">conda activate voldor</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install the python dependencies</span></span><br><span class="line">cd slam_py/install</span><br><span class="line">pip install -r ./requirements.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install OpenCV</span></span><br><span class="line">sudo apt install libopencv-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PyOpenGL</span></span><br><span class="line">sudo apt install python-opengl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ceres: http://ceres-solver.org/installation.html</span></span><br><span class="line">wget https://github.com/ceres-solver/ceres-solver/archive/refs/tags/2.1.0.tar.gz</span><br><span class="line">tar -zxvf 2.1.0.tar.gz</span><br><span class="line">mv ceres-solver-2.1.0 ceres-solver</span><br><span class="line">cd ceres-solver</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake ..</span><br><span class="line">sudo make install -j12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pyDBoW3</span></span><br><span class="line">git clone https://github.com/htkseason/pyDBoW3.git</span><br></pre></td></tr></table></figure>

<p>libboost.python</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://boostorg.jfrog.io/artifactory/main/release/1.68.0/source/boost_1_68_0.tar.gz</span><br></pre></td></tr></table></figure>

<p>在编译安装 pyDBoW3时遇到一些问题，把 build.sh 文件拆分一步步执行，排除错误。</p>
<p>VOLDOR&#x2F;slam_py&#x2F;install&#x2F;pyDBoW3&#x2F;src&#x2F;CMakeLists.txt 中加入 DBoW3 路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(DBoW3_DIR /home/data1/sebas/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3/lib/cmake/DBoW3)</span><br><span class="line">SET(DBoW3_USE_STATIC_LIBS ON)</span><br><span class="line">find_package(DBoW3 REQUIRED)</span><br></pre></td></tr></table></figure>

<p>然后执行在 pyDBoW3&#x2F;build 目录下执行 cmake 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cmake -DBUILD_PYTHON3=on \</span><br><span class="line">      -DPYTHON_EXECUTABLE=/usr/bin/python3.6 \</span><br><span class="line">      -DBUILD_STATICALLY_LINKED=OFF \</span><br><span class="line">      -DOpenCV_DIR=/data/zhangjiguang/wzq/projects/VOLDOR/slam_py/install/pyDBoW3/install/opencv3/build \</span><br><span class="line">      -DDBoW3_DIR=/data/zhangjiguang/wzq/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3/build \</span><br><span class="line">      -DDBoW3_INCLUDE_DIRS=/data/zhangjiguang/wzq/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3/src \</span><br><span class="line">      -DCMAKE_BUILD_TYPE=Release ../src</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入路径的方法：在CMakeLists.txt中更改；或者在命令行设置全局变量</span> </span><br><span class="line">export DBoW3_DIR=/home/data1/sebas/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3</span><br><span class="line">export CMAKE_PREFIX_PATH=/home/data1/sebas/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3:$CMAKE_PREFIX_PATH</span><br><span class="line"></span><br><span class="line">export CMAKE_PREFIX_PATH=/usr/lib/x86_64-linux-gnu:$CMAKE_PREFIX_PATH</span><br><span class="line"></span><br><span class="line">sudo make -j12</span><br></pre></td></tr></table></figure>

<p>以上命令都执行成功后，在 build 目录下会生成一个 pyDBoW3.so 文件，将其复制到 demo 目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">build vo only</span></span><br><span class="line">cd slam_py/install  </span><br><span class="line">python setup_linux_vo.py build_ext -i</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">build full slam pipeline</span></span><br><span class="line">cd slam_py/install  </span><br><span class="line">python setup_linux_full.py build_ext -i</span><br></pre></td></tr></table></figure>

<h2 id="1-2-AI-IMU"><a href="#1-2-AI-IMU" class="headerlink" title="1.2 AI-IMU"></a>1.2 AI-IMU</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ai-imu</span></span><br><span class="line">conda create -n ai-imu python==3.6.9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install dependencies</span></span><br><span class="line">pip install matplotlib numpy termcolor scipy navpy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">torch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本会报错</span></span><br><span class="line">conda install pytorch==1.12.1 torchvision==0.13.1 torchaudio==0.12.1 cudatoolkit=10.2 -c pytorch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用旧版本</span></span><br><span class="line">conda install pytorch torchvision cudatoolkit=10.2</span><br></pre></td></tr></table></figure>

<p>clone the repo and test</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">clone</span></span> </span><br><span class="line">git clone https://github.com/mbrossar/ai-imu-dr.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Download reformated pickle format of the 00-11 KITTI IMU raw data</span></span><br><span class="line">wget &quot;https://www.dropbox.com/s/ey41xsvfqca30vv/data.zip&quot;</span><br><span class="line">mkdir ai-imu-dr/results</span><br><span class="line">unzip data.zip -d ai-imu-dr</span><br><span class="line">rm data.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Download training parameters</span></span><br><span class="line">wget &quot;https://www.dropbox.com/s/77kq4s7ziyvsrmi/temp.zip&quot;</span><br><span class="line">unzip temp.zip -d ai-imu-dr/temp</span><br><span class="line">rm temp.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Test the filters</span></span><br><span class="line">cd ai-imu-dr/src</span><br><span class="line">python3 main_kitti.py</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Docker"><a href="#1-3-Docker" class="headerlink" title="1.3 Docker"></a>1.3 Docker</h2><p>ubuntu 安装 docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt install docker.io nvidia-docker2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 docker 用户组</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将用户加入 docker 用户组</span></span><br><span class="line">sudo gpasswd -a <span class="variable">$&#123;username&#125;</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker 应用</span></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加访问和执行权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> a+rw /var/run/docker.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换 docker 默认存储位置及镜像源</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将默认位置的 docker 文件夹复制到新目录</span></span><br><span class="line">sudo <span class="built_in">mv</span> /var/lib/docker /home/data1/</span><br><span class="line"></span><br><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为修改内容</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;runtimes&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;nvidia&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;path&quot;</span>: <span class="string">&quot;nvidia-container-runtime&quot;</span>,</span><br><span class="line">            <span class="string">&quot;runtimeArgs&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;data-root&quot;</span>:<span class="string">&quot;/home/data1/docker&quot;</span>,</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>:[</span><br><span class="line">                        <span class="string">&quot;https://hub-mirror.c.163.com/&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span></span><br><span class="line">                        ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker 服务</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前文件夹及文件大小</span></span><br><span class="line">sudo <span class="built_in">du</span> -h --max-depth=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># df 以磁盘分区为单位查看文件系统</span></span><br><span class="line"><span class="built_in">df</span> -lh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像:https://hub.docker.com/r/nvidia/cuda/tags?page=3&amp;name=18</span></span><br><span class="line">docker pull nvidia/cuda:11.4.0-devel-ubuntu18.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">sudo docker run --<span class="built_in">rm</span> --gpus all nvidia/cuda:11.4.0-devel-ubuntu18.04 nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># -i 控制台交互  -t 支持终端登录  -d 指定容器运行于后台</span></span><br><span class="line"><span class="comment"># -v 给容器挂载存储卷，挂载到容器某个目录（前者是宿主机目录，后者是容器目录，中间以:分隔）</span></span><br><span class="line"><span class="comment"># -p 端口映射（前者是宿主机目录，后者是容器目录，中间以:分隔，例如 -p 80:80）</span></span><br><span class="line"><span class="comment"># -m  --memory=[] 指定容器内存上限</span></span><br><span class="line"><span class="comment"># --name=[] 指定容器名字</span></span><br><span class="line"><span class="comment"># --gpus all 使用宿主机gpu</span></span><br><span class="line"><span class="comment"># --rm 容器停止后自动删除容器，常用来测试</span></span><br><span class="line">docker run -itd -v ~/work:/work --name=Ubuntu20.04-CUDA --gpus all nvidia/cuda:11.4.2-cudnn8-devel-ubuntu20.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># Titan X</span></span><br><span class="line">docker run --gpus all -itd --privileged=<span class="literal">true</span> -p 50097:22 --name voldor-imu \</span><br><span class="line">       -v /home/data1/projects:/home/projects \</span><br><span class="line">       -e DISPLAY=<span class="variable">$DISPLAY</span> \</span><br><span class="line">       -e GDK_SCALE \</span><br><span class="line">       -e GDK_DPI_SCALE \</span><br><span class="line">       nvidia/cuda:11.4.0-devel-ubuntu18.04 /bin/bash</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="comment"># A6000</span></span><br><span class="line">docker run --gpus all -itd --privileged=<span class="literal">true</span> -p 50097:22 --name voldor-imu \</span><br><span class="line">       -v /data/zhangjiguang/wzq/voldor-imu:/home/voldor-imu \</span><br><span class="line">       -e DISPLAY=<span class="variable">$DISPLAY</span> \</span><br><span class="line">       -e GDK_SCALE \</span><br><span class="line">       -e GDK_DPI_SCALE \</span><br><span class="line">       nvidia/cuda:11.4.0-devel-ubuntu18.04 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的容器ID</span></span><br><span class="line">docker ps -a </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入已创建的容器</span></span><br><span class="line">docker attach [ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 root 密码</span></span><br><span class="line">passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ssh</span></span><br><span class="line">apt update</span><br><span class="line">apt install openssh-server vim wget curl cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 ssh 配置文件</span></span><br><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">Port 22</span><br><span class="line">PermitRootLogin <span class="built_in">yes</span>  </span><br><span class="line">UsePAM no</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">service ssh restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># connect</span></span><br><span class="line">ssh root@10.1.16.116 -X -p 50096</span><br><span class="line"></span><br><span class="line"><span class="comment"># DISPLAY</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=10.1.16.227:0.0</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DISPLAY</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">apt install x11-apps</span><br><span class="line">xclock</span><br></pre></td></tr></table></figure>

<p>其他源介绍：</p>
<p>科大镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></p>
<p>网易：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></p>
<p>七牛云加速器：<a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></p>
<p>Docker中国区官方镜像：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></p>
<p>阿里云：https:&#x2F;&#x2F;阿里云镜像服务id.mirror.aliyuncs.com</p>
<p>原文链接：<a href="https://blog.csdn.net/m0_37282062/article/details/115770314">https://blog.csdn.net/m0_37282062/article/details/115770314</a></p>
<h3 id="1-3-1-docker-换源及存储位置"><a href="#1-3-1-docker-换源及存储位置" class="headerlink" title="1.3.1 docker 换源及存储位置"></a>1.3.1 docker 换源及存储位置</h3><h3 id="1-3-2-打包发布镜像"><a href="#1-3-2-打包发布镜像" class="headerlink" title="1.3.2 打包发布镜像"></a>1.3.2 打包发布镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit 07da voldor-imu:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># tag</span></span><br><span class="line">docker tag voldor-imu:v1 wzq11011/voldor-imu:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># push</span></span><br><span class="line">docker push wzq11011/voldor-imu:v1</span><br></pre></td></tr></table></figure>





<p>退出容器但不关闭容器：ctrl+p+q</p>
<p>vscode 修改文件提示没有权限，修改文件所有者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归修改文件所有者</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R sebas projects/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改用户组</span></span><br><span class="line"><span class="built_in">chgrp</span> -R sebas projects/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/htkseason/VOLDOR.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mbrossar/ai-imu-dr.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3.6.9</span></span><br><span class="line">python3</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip</span></span><br><span class="line">apt install python3-pip</span><br><span class="line"></span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># ceres-solver</span></span><br><span class="line"><span class="comment"># http://ceres-solver.org/installation.html#linux</span></span><br><span class="line">apt install cmake libgoogle-glog-dev libgflags-dev libatlas-base-dev libeigen3-dev libsuitesparse-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># boost</span></span><br><span class="line"><span class="comment"># https://blog.csdn.net/qq_41854911/article/details/119454212</span></span><br><span class="line">apt install libboost-all-dev</span><br><span class="line">docker <span class="built_in">exec</span> -it 07da /bin/bash</span><br></pre></td></tr></table></figure>

<h1 id="2-报错信息记录："><a href="#2-报错信息记录：" class="headerlink" title="2 报错信息记录："></a>2 报错信息记录：</h1><h2 id="2-1-cmake版本问题"><a href="#2-1-cmake版本问题" class="headerlink" title="2.1 cmake版本问题"></a>2.1 cmake版本问题</h2><p>报错：internal error, please report: running “cmake” failed: cannot create transient scope: DBus error “org.freedesktop.DBus.Error.TimedOut”: [Failed to activate service ‘org.freedesktop.systemd1’: timed out (service_start_timeout&#x3D;25000ms)]</p>
<p>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip uninstall cmake</span><br><span class="line"></span><br><span class="line">sudo apt install cmake</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后再重新编译解决</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Boost"><a href="#2-2-Boost" class="headerlink" title="2.2 Boost"></a>2.2 Boost</h2><p>报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- Boost 1.54 found.</span><br><span class="line">CMake Error at /usr/lib/cmake/Boost-1.81.0/BoostConfig.cmake:141 (find_package):</span><br><span class="line">  Could not find a package configuration file provided by &quot;boost_python-py36&quot;</span><br><span class="line">  (requested version 1.81.0) with any of the following names:</span><br><span class="line"></span><br><span class="line">    boost_python-py36Config.cmake</span><br><span class="line">    boost_python-py36-config.cmake</span><br><span class="line"></span><br><span class="line">  Add the installation prefix of &quot;boost_python-py36&quot; to CMAKE_PREFIX_PATH or</span><br><span class="line">  set &quot;boost_python-py36_DIR&quot; to a directory containing one of the above</span><br><span class="line">  files.  If &quot;boost_python-py36&quot; provides a separate development package or</span><br><span class="line">  SDK, be sure it has been installed.</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  /usr/lib/cmake/Boost-1.81.0/BoostConfig.cmake:262 (boost_find_component)</span><br><span class="line">  /usr/share/cmake-3.10/Modules/FindBoost.cmake:242 (find_package)</span><br><span class="line">  CMakeLists.txt:130 (FIND_PACKAGE)</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动下载编译 boost</span></span><br><span class="line">wget https://boostorg.jfrog.io/artifactory/main/release/1.68.0/source/boost_1_68_0.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf boost_1_68_0.tar.gz</span><br><span class="line"></span><br><span class="line">./bootstrap.sh --with-libraries=all --with-toolset=gcc</span><br><span class="line">./b2</span><br><span class="line">sudo ./b2 install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<h2 id="2-3-opencv"><a href="#2-3-opencv" class="headerlink" title="2.3 opencv"></a>2.3 opencv</h2><p>执行demo的时候报错</p>
<blockquote>
<p>报错信息如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread Thread-29:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.6/threading.py&quot;</span>, line 916, <span class="keyword">in</span> _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.6/threading.py&quot;</span>, line 864, <span class="keyword">in</span> run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File <span class="string">&quot;../slam_py/voldor_slam.py&quot;</span>, line 718, <span class="keyword">in</span> vo_thread</span><br><span class="line">    cv2.imshow(<span class="string">&#x27;tmpkf_depth&#x27;</span>, (self.basefocal*0.04)/self.frames[self.fid_cur_tmpkf].get_scaled_depth())</span><br><span class="line">cv2.error: OpenCV(4.7.0) /tmp/pip-install-ftep5xuc/opencv-python_faa811634b06405b915df5c9319b9c00/opencv/modules/highgui/src/window.cpp:1272: error: (-2:Unspecified error) The <span class="keyword">function</span> is not implemented. Rebuild the library with Windows, GTK+ 2.x or Cocoa support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, <span class="keyword">then</span> re-run cmake or configure script <span class="keyword">in</span> <span class="keyword">function</span> <span class="string">&#x27;cvShowImage&#x27;</span></span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 opencv-python 版本</span></span><br><span class="line">pip show opencv-python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装对应版本的 opencv-contrib</span></span><br><span class="line">pip install opencv-contrib-python==4.7.0.72</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_46018888/article/details/121430749">https://blog.csdn.net/qq_46018888/article/details/121430749</a></p>
<h1 id="3-论文"><a href="#3-论文" class="headerlink" title="3 论文"></a>3 论文</h1><h2 id="3-1-VOLDOR-SLAM"><a href="#3-1-VOLDOR-SLAM" class="headerlink" title="3.1 VOLDOR-SLAM"></a>3.1 VOLDOR-SLAM</h2><h3 id="3-1-1-摘要总结"><a href="#3-1-1-摘要总结" class="headerlink" title="3.1.1 摘要总结"></a>3.1.1 摘要总结</h3><p>作者提出了一种基于外部密集光流输入的密集间接SLAM系统。扩展了概率视觉里程计模型VOLDOR [Min et al. CVPR’20]，通过引入几何先验来从单目捕获中鲁棒地引导估计，同时无缝地支持立体或RGB-D图像。论文中定制的后端将中间几何估计与管理增量姿态图连接性的自适应优先级方案紧密耦合。利用密集光流方法的最新进展，实现了准确和稳健的相机姿态估计，同时构建了细粒度的全局一致的密集环境地图。我们的开源实现在单个GTX1080Ti GPU上在线运行，速度约为15 FPS。</p>
<p>相关工作部分回顾了间接SLAM、直接SLAM和密集光流方法的相关文献，并指出了它们的优缺点。间接SLAM方法通过稀疏关键点匹配来建立帧间的几何关系，然后通过PnP或BA等算法来估计相机姿态和场景结构。这些方法通常可以实时运行，但是可能受到缺乏纹理、重复结构或退化几何配置等因素的影响。直接SLAM方法通过联合光流估计一致的场景结构和相机姿态来避免关键点匹配，但是这些方法通常对光照变化敏感，需要精确的光度校准，并且需要有足够的纹理区域。密集光流方法通过计算帧间像素级别的运动来提供稠密的几何信息，计算成本高昂，并且可能受到遮挡、运动模糊或低纹理等因素的影响。</p>
<h3 id="3-1-2-使用方法"><a href="#3-1-2-使用方法" class="headerlink" title="3.1.2 使用方法"></a>3.1.2 使用方法</h3><p>论文中使用的方法是<strong>密集间接SLAM</strong>，它基于外部密集光流输入来估计相机姿态和场景结构。论文的方法分为两个部分：前端和后端。</p>
<ul>
<li>前端部分是基于VOLDOR的概率视觉里程计模型，它使用密集光流残差来建立帧间的几何关系，并利用几何先验来从单目、双目或RGB-D图像中恢复相机运动和深度图。前端部分还包括了一个帧对齐模块，用于校正光流估计的误差，并提高深度图的质量。</li>
<li>后端部分是一个定制的位姿图优化模块，它将前端的几何估计与一个自适应的优先级方案紧密耦合，以管理增量位姿图的连接性。后端部分还包括了一个地图重建模块，用于从关键帧的深度图中构建细粒度的全局一致的密集环境地图。</li>
</ul>
<h3 id="3-1-3-实验部分"><a href="#3-1-3-实验部分" class="headerlink" title="3.1.3 实验部分"></a>3.1.3 实验部分</h3><ul>
<li>实验部分首先介绍了实验的设置和评估指标，包括相机姿态误差、绝对轨迹误差、相对姿态误差和地图重建误差等。</li>
<li>然后在四个数据集上进行了实验，分别是TartanAir、KITTI、EuRoC和TUM RGB-D。这些数据集涵盖了不同的输入模式、场景复杂度和运动模式，以验证论文的方法的通用性和鲁棒性。</li>
<li>接着展示了论文的方法在不同输入模式下的定量结果，包括单目、双目和RGB-D。实验结果表明，论文的方法在所有数据集上都取得了优秀的性能，超过了其他SLAM方法的表现。</li>
<li>最后展示了论文的方法在不同输入模式下的定性结果，包括相机轨迹、深度图和密集地图。实验结果显示，论文的方法能够有效地估计相机姿态和场景结构，并构建细粒度的全局一致的密集环境地图。</li>
</ul>
<h2 id="3-2-AI-IMU"><a href="#3-2-AI-IMU" class="headerlink" title="3.2 AI-IMU"></a>3.2 AI-IMU</h2><h3 id="3-2-1-摘要总结"><a href="#3-2-1-摘要总结" class="headerlink" title="3.2.1 摘要总结"></a>3.2.1 摘要总结</h3><p>论文的主要贡献是提出了一种基于惯性测量单元（IMU）的新颖准确的车辆自定位方法：论文的主要思想是利用卡尔曼滤波器和深度神经网络来动态地调整滤波器的噪声参数。作者在KITTI里程计数据集上进行了实验，证明了该方法仅使用IMU就能准确地估计车辆的三维位置、速度、方向和IMU偏差。其结果在平均平移误差上达到了1.10%，与使用激光雷达或立体视觉的顶级方法相媲美。</p>
<h3 id="3-2-2-论文结构"><a href="#3-2-2-论文结构" class="headerlink" title="3.2.2 论文结构"></a>3.2.2 论文结构</h3><p>论文使用的方法主要包括以下几个部分：</p>
<ul>
<li>基于IMU的自定位模型，使用一个非线性状态空间模型来描述车辆的运动状态和IMU的偏差，其中状态变量包括位置、速度、方向、陀螺仪偏差和加速度计偏差。</li>
<li>卡尔曼滤波器，使用一个扩展卡尔曼滤波器（EKF）来根据IMU的测量值对状态变量进行估计和更新，其中测量方程是一个恒等映射。</li>
<li>神经网络，使用一个多层感知机（MLP）来根据IMU的测量值和历史噪声参数来预测当前的噪声参数，包括过程噪声协方差矩阵和测量噪声协方差矩阵。</li>
<li>训练策略，使用一个端到端的训练策略来同时优化EKF和MLP的参数，目标函数是最小化EKF的估计误差和MLP的预测误差。</li>
</ul>
<h3 id="3-2-3-实验部分"><a href="#3-2-3-实验部分" class="headerlink" title="3.2.3 实验部分"></a>3.2.3 实验部分</h3><ul>
<li>数据集，使用KITTI里程计数据集，该数据集包含了22个序列的车辆运动数据，其中11个序列提供了地面真值1。论文使用了前10个序列作为训练集，后一个序列作为测试集。</li>
<li>评估指标，使用平均平移误差（ATE）和平均方向误差（AOE）来评估定位的准确性。ATE是指估计的轨迹与地面真值之间的欧氏距离的平均值。AOE是指估计的方向与地面真值之间的角度差的平均值。</li>
<li>实现细节，使用PyTorch框架实现了EKF和MLP的模型。EKF的状态维度是15，测量维度是6。MLP有两个隐藏层，每层有64个神经元，激活函数是ReLU。训练时使用Adam优化器，学习率是0.001，批大小是256，训练轮数是1000。</li>
</ul>
<p>结果分析，使用不同的方法在测试集上进行了定位，并与其他基于激光雷达或立体视觉的方法进行了比较。结果显示，论文提出的方法在ATE上达到了1.10%的误差，在AOE上达到了0.33°的误差。这些结果优于其他仅使用IMU的方法，并且与使用其他传感器的方法相当或更好。</p>
<h3 id="3-2-4-代码部分"><a href="#3-2-4-代码部分" class="headerlink" title="3.2.4 代码部分"></a>3.2.4 代码部分</h3><p>仅使用惯性测量单元在 KITTI 里程计数据集上的平移误差位 1.10%</p>
<p><img src="/./Voldor.assets/(null)-20230518214845352.(null)" alt="img"></p>
<ul>
<li><p>main_kitti.py</p>
</li>
<li><ul>
<li>导入必要的模块和库</li>
<li>class KITTIParameters 定义KITTI数据集参数和类</li>
<li>class KITTIDataset 读取KITTI数据集文件并处理</li>
<li>def test_filter 定义测试滤波器</li>
<li>def launch(<em>args</em>) 程序入口，通过调节read_data的值，来选择是否读数据集。train_filter、test_filter、results_filter<ul>
<li>train_filter()</li>
<li>test_filter()</li>
<li>results_filter()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>卡尔曼滤波是一种用于估计系统状态的递归滤波器，</p>
<h1 id="4-光流与IMU结合"><a href="#4-光流与IMU结合" class="headerlink" title="4 光流与IMU结合"></a>4 光流与IMU结合</h1><ul>
<li>AI-IMU：对IMU数据进行预处理，得到初始的相机姿态和场景结构的估计，以及IMU偏差的自校准。</li>
<li>VOLDOR：对密集光流数据进行处理，得到帧间的几何关系和深度图，以及帧对齐的校正。</li>
<li>将AI-IMU方法和论文的方法的输出作为位姿图优化模块的输入，利用自适应优先级方案来管理增量位姿图的连接性，并进行全局优化。</li>
<li>使用地图重建模块对关键帧的深度图进行融合，得到细粒度的全局一致的密集环境地图。</li>
</ul>
]]></content>
      <tags>
        <tag>voldor</tag>
      </tags>
  </entry>
  <entry>
    <title>捡垃圾</title>
    <url>/posts/35352.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一台：E3-1230-v2-GTX-960"><a href="#第一台：E3-1230-v2-GTX-960" class="headerlink" title="第一台：E3 1230 v2 + GTX 960"></a>第一台：E3 1230 v2 + GTX 960</h2><p>个人组装的第一台电脑，矿潮时期（22年2月份） 725 元买的显卡，主板用过盈通的 h61 和技嘉的 b75 ，都是用一两年就出问题，不是很稳定，遂花重金购入华南金牌 b75，用到现在暂时没出现问题。</p>
<p><img src="https://pub-2a3b01d25dc54294ad367b0fbbf69705.r2.dev/20250227095859317.png" alt="e31230v2"></p>
<h2 id="第二台：E3-1246-v3-RX460"><a href="#第二台：E3-1246-v3-RX460" class="headerlink" title="第二台：E3 1246 v3  + RX460"></a>第二台：E3 1246 v3  + RX460</h2><blockquote>
<p>买了两块主板，一块技嘉 g1 sniper b6，用了一年黑屏无法开机；另一块华硕 b85 ，中间有段时间也是点不亮，放了一段时间又能点亮了（玄学）。这块板子一直用到现在，甚至配了一张 RX460，装了个黑苹果。</p>
</blockquote>
<p><img src="https://pub-2a3b01d25dc54294ad367b0fbbf69705.r2.dev/e31246v3.png" alt="e31246v3"></p>
<p>黑苹果：macOS12</p>
<p><img src="https://pub-2a3b01d25dc54294ad367b0fbbf69705.r2.dev/e3mac.png" alt="e3mac"></p>
<h2 id="第三台：惠普-800G1-USDT"><a href="#第三台：惠普-800G1-USDT" class="headerlink" title="第三台：惠普 800G1 USDT"></a>第三台：惠普 800G1 USDT</h2><h2 id="主力机：神舟-tx8"><a href="#主力机：神舟-tx8" class="headerlink" title="主力机：神舟 tx8"></a>主力机：神舟 tx8</h2><h2 id="n1-盒子"><a href="#n1-盒子" class="headerlink" title="n1 盒子"></a>n1 盒子</h2><h2 id="玩客云"><a href="#玩客云" class="headerlink" title="玩客云"></a>玩客云</h2><h2 id="wifi-棒子"><a href="#wifi-棒子" class="headerlink" title="wifi 棒子"></a>wifi 棒子</h2>]]></content>
      <categories>
        <category>装机</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>捡垃圾</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h2 id="Stellar"><a href="#Stellar" class="headerlink" title="Stellar"></a>Stellar</h2><p>stellar: <a href="https://xaoxuu.com/wiki/stellar/tag-plugins/express/">stellar</a></p>
<div class="tag-plugin colorful okr" >
  <div class="okr-item o" id="okr-o1">
    <div class="okr-left">
      <span class="title">O1</span>
    </div>
    <div class="okr-center">
      <span class="title">2024年的小目标：完成 Volantis 6.0 并发布上线</span>
      <div class="note"><p>来自2025年的复盘：已《基本》实现目标 <span class="tag-plugin emoji"><img no-lazy="" class="inline" src="https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/滑稽.png"/></span></p></div>
    </div>
    <div class="okr-right colorful" color="blue">
      <div class="labels">
        <span class="status label">正常</span>
        <span class="status percent">44%</span>
      </div>
      <div class="progress">
        <div class="fill" style="width:44%;"></div>
      </div>
    </div>
  </div>
  
  <div class="okr-item kr" id="okr-kr1">
    <div class="okr-left">
      <span class="title">KR1</span>
    </div>
    <div class="okr-center">
      <span class="title">重构 tag-plugins 和 wiki 系统</span>
      <div class="note"><ul><li>当 <mark class="tag-plugin colorful mark" color="yellow">KR</mark> 进度为 100% 时，标签默认显示为 <mark class="tag-plugin colorful mark" color="green">已完成</mark></li><li>当 <mark class="tag-plugin colorful mark" color="yellow">KR</mark> 未设置进度时，默认为 <mark class="tag-plugin colorful mark" color="yellow">0%</mark></li><li>当 <mark class="tag-plugin colorful mark" color="yellow">O</mark> 未设置进度时，则显示所有 <mark class="tag-plugin colorful mark" color="yellow">KR</mark> 进度平均值</li></ul></div>
    </div>
    <div class="okr-right colorful" color="green">
      <div class="labels">
        <span class="status label">已完成</span>
        <span class="status percent">100%</span>
      </div>
      <div class="progress">
        <div class="fill" style="width:100%;"></div>
      </div>
    </div>
  </div>
  
  <div class="okr-item kr" id="okr-kr2">
    <div class="okr-left">
      <span class="title">KR2</span>
    </div>
    <div class="okr-center">
      <span class="title">完成主要页面设计稿</span>
      <div class="note"><div class="tag-plugin tabs" align="left"id="tab_1"><div class="nav-tabs"><div class="tab active"><a href="#tab_1-1">小提示1</a></div><div class="tab"><a href="#tab_1-2">小提示2</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><p>您可以在 _config.yml 文件中修改标签的颜色和文案</p></div><div class="tab-pane" id="tab_1-2"><p>您可以在 _config.yml 文件中增加任意的标签配置</p></div></div></div></div>
    </div>
    <div class="okr-right colorful" color="orange">
      <div class="labels">
        <span class="status label">延期</span>
        <span class="status percent">90%</span>
      </div>
      <div class="progress">
        <div class="fill" style="width:90%;"></div>
      </div>
    </div>
  </div>
  
  <div class="okr-item kr" id="okr-kr3">
    <div class="okr-left">
      <span class="title">KR3</span>
    </div>
    <div class="okr-center">
      <span class="title">完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹）</span>
      <div class="note"><div class="tag-plugin colorful checkbox" ><input type="checkbox"/><span>在咸水和海滩之间找一亩地</span></div><div class="tag-plugin colorful checkbox" ><input type="checkbox"/><span>求出圆周率后15位</span></div><div class="tag-plugin colorful checkbox" ><input type="checkbox"/><span>找出宇宙的终极逻辑</span></div><div class="tag-plugin colorful checkbox" ><input type="checkbox"/><span>去地狱里走两步</span></div></div>
    </div>
    <div class="okr-right colorful" color="red">
      <div class="labels">
        <span class="status label">未完成</span>
        <span class="status percent">-12%</span>
      </div>
      <div class="progress">
        <div class="fill" style="width:-12%;"></div>
      </div>
    </div>
  </div>
  
  <div class="okr-item kr" id="okr-kr-4">
    <div class="okr-left">
      <span class="title">KR-4</span>
    </div>
    <div class="okr-center">
      <span class="title">开发、测试和发布</span>
      <div class="note"><div class="tag-plugin image"><div class="image-bg"><img src="/assets/wiki/stellar/icon.svg" alt="支持嵌套插入图片等其它简单组件" style="height:64px;"/></div><div class="image-meta"><span class="image-caption center">支持嵌套插入图片等其它简单组件</span></div></div></div>
    </div>
    <div class="okr-right colorful" color="yellow">
      <div class="labels">
        <span class="status label">风险</span>
        <span class="status percent">0%</span>
      </div>
      <div class="progress">
        <div class="fill" style="width:0%;"></div>
      </div>
    </div>
  </div>
  </div>
]]></content>
  </entry>
  <entry>
    <title>hot 100</title>
    <url>/posts/35102.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Leetcode hot 100 刷题记录</p>
</blockquote>
<h1 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1 哈希"></a>1 哈希</h1><p>基础知识：</p>
<ul>
<li>unordered_map：基于哈希表（Hash Table）实现，用于存储键值对。通过哈希函数将键转化为哈希码，然后使用哈希码作为索引快速定位到桶（bucket），每个桶内可能包含多个元素（当发生哈希冲突时） 对于查找、插入和删除操作，在理想情况下，时间复杂度为<code>O(1)</code>。<ul>
<li>insert({key,value})：使用 pair 插入元素</li>
<li>emplace({key, value})：使用 emplace_back 方式构造并插入元素</li>
<li>erase()、clear() 删除所有元素</li>
<li>size()、empty() 映射为空则返回 true、bucket_count() 返回桶数量</li>
<li>begin()、end()、bucket() （返回键所在的桶编号）</li>
</ul>
</li>
<li>unordered_set：一种关联容器，类似于 <code>set</code> ，无序，基于哈希表实现。容器中每一个元素都是唯一的，可以高效地插入、删除、查找。<ul>
<li>插入元素：insert()</li>
<li>查找元素</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mySet.<span class="built_in">find</span>(<span class="number">42</span>) != mySet.<span class="built_in">end</span>())  <span class="comment">// 元素存在</span></span><br><span class="line"><span class="keyword">if</span> (mySet.<span class="built_in">count</span>(<span class="string">&quot;banana&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// banana 存在于集合中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素：erase()</li>
<li>遍历元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : mySet) &#123;</span><br><span class="line">    <span class="comment">// 遍历并处理每个元素</span></span><br><span class="line">    std::count &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>emplace()</code>：在容器内直接构造元素。</li>
<li><code>empty()</code>：检查容器是否为空。</li>
<li><code>size()</code>：获取容器中元素的数量。</li>
<li><code>clear()</code>：清空所有元素。</li>
</ul>
<p>（emplace主要用在序列容器汇总，emplace_back主要用在序列容器中）</p>
<ul>
<li>emplace_back：是 C++ 标准库中某些容器类（如 vector、deque、list等序列容器，以及 unordered_map、map等关联容器）提供的成员函数，该方法允许在容器的末尾直接构造新的元素，而不用先创建好元素再插入。避免了额外拷贝或移动构造函数的调用，相比较于先创建临时变量再用 <code>push_back</code> 添加的方式，这种方法更高效，省去了临时对象的创建和销毁过程。</li>
</ul>
<h2 id="1-1-字母异位词"><a href="#1-1-字母异位词" class="headerlink" title="1.1 字母异位词"></a>1.1 字母异位词</h2><p>题目链接：<a href="https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
<p>思路：</p>
<ul>
<li>判断两个字符串是否相等，可以对字符串中的字母做排序，然后比较二者是否相等。</li>
<li>使用哈希表存储每一组字母异位词，键为字母异位词标志（排序后的字符串），值为字母异位词。</li>
</ul>
<p>方法一：字母排序</p>
<ul>
<li>时间复杂度：<code>O(NKlogK)</code><ul>
<li>遍历单词：<code>O(N)</code></li>
<li>排序字符：<code>O(KlogK)</code></li>
</ul>
</li>
<li>空间复杂度：<code>O(NK)</code></li>
</ul>
<p><code>n</code> 是 <code>strs</code> 中字符串的数量，<code>k</code> 是 <code>strs</code> 中字符串的最大长度。需要使用哈希表存储全部字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            map[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            result.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：字符计数 （代码未理解）</p>
<p> 互为字母异位词的两个字符串包含的字母相同，相同字母出现的次数也相同，可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="comment">// 自定义对 array&lt;int, 26&gt; 类型的哈希函数</span></span><br><span class="line">        <span class="keyword">auto</span> arrayHash = [fn = hash&lt;<span class="type">int</span>&gt;&#123;&#125;] (<span class="type">const</span> array&lt;<span class="type">int</span>, <span class="number">26</span>&gt;&amp; arr) -&gt; <span class="type">size_t</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">accumulate</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">0u</span>, [&amp;](<span class="type">size_t</span> acc, <span class="type">int</span> num) &#123;</span><br><span class="line">                <span class="built_in">return</span> (acc &lt;&lt; <span class="number">1</span>) ^ <span class="built_in">fn</span>(num);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;array&lt;<span class="type">int</span>, 26&gt;, vector&lt;string&gt;, <span class="keyword">decltype</span>(arrayHash)&gt; <span class="built_in">mp</span>(<span class="number">0</span>, arrayHash);</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str: strs) &#123;</span><br><span class="line">            array&lt;<span class="type">int</span>, 26&gt; counts&#123;&#125;;</span><br><span class="line">            <span class="type">int</span> length = str.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">                counts[str[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[counts].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-最长连续序列"><a href="#1-2-最长连续序列" class="headerlink" title="1.2 最长连续序列"></a>1.2 最长连续序列</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：枚举数组中每一个数 <code>x</code> ，以此数为起点找连续序列（即不断寻找 <code>x+1</code> 、<code>x+2</code> 、<code>x+3</code> … <code>x+y</code> ），假设最长匹配到了 <code>x+y</code> ，则以 <code>x</code> 为起点的最长序列长度为 <code>y+1</code> 。</p>
<p>优化：</p>
<p>1、使用 set 对数组去重，避免重复的起点。</p>
<p>2、如果已知有一个 <code>x,x+1,x+2,⋯,x+y</code> 的连续序列，则以 <code>x+1，x+2,...,x+y</code> 中的数为起点造成重复。以要枚举的起点为 <code>x</code> 为例，在哈希表中检查是否存在 <code>x-1</code> 来判断是否跳过该起点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_set.<span class="built_in">find</span>(num<span class="number">-1</span>) == num_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> currentNum = num;</span><br><span class="line">                <span class="type">int</span> currentLength = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (num_set.<span class="built_in">find</span>(currentNum + <span class="number">1</span>) != num_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                    currentLength++;</span><br><span class="line">                &#125;</span><br><span class="line">                result = <span class="built_in">max</span>(result, currentLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2 双指针"></a>2 双指针</h1><h2 id="2-1-移动零"><a href="#2-1-移动零" class="headerlink" title="2.1 移动零"></a>2.1 移动零</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：左指针找零，右指针找非零数，然后交换并右移，直到数组最后一个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) <span class="built_in">swap</span>(nums[left], nums[right]); </span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
<h2 id="2-2-盛最多水的容器"><a href="#2-2-盛最多水的容器" class="headerlink" title="2.2 盛最多水的容器"></a>2.2 盛最多水的容器</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：以双指针为数组的左右边界，固定一个指针，移动另一个指针，不断地计算面积从而得到容量的最大值。</p>
<p>优化：</p>
<p>1、如果左指针高度比右指针低，则固定右指针，移动左指针，反之亦然。（我们期望较小的一边在移动过程中变大，从而增加盛水容量）</p>
<p>2、如果移动后高度小于等于原高度，则面积必然减小，省略计算面积的步骤。（简化计算）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            result = <span class="built_in">max</span>(result, <span class="built_in">min</span>(height[left], height[right]) * (right - left));</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt;= height[right]) left++;</span><br><span class="line">            <span class="keyword">else</span> right--; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-三数之和"><a href="#2-3-三数之和" class="headerlink" title="2.3 三数之和"></a>2.3 三数之和</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：for 循环里面包着左右指针。<code>i</code> 的下标从 0 开始，定义 <code>left</code> 在 <code>i+1</code> 位置上， <code>right</code> 在数组末尾上。判断 <code>nums[i]+nums[left]+nums[right]</code> 的值，大于 0 右指针左移，小于 0 左指针右移。</p>
<p>优化：</p>
<p>1、如果排序后第一个元素大于0，则三数合必大于0；</p>
<p>2、对 i 去重，如果当前的 <code>nums[i]</code> 与前一个相等，则跳过</p>
<p>3、对 <code>left right</code> 去重，类似第 2 步。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// for 循环里面包着左右指针</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">            <span class="comment">// 对 i 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 找到一组三元组后，对 left 和 right 去重</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-接雨水"><a href="#2-4-接雨水" class="headerlink" title="2.4 接雨水"></a>2.4 接雨水</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：</p>
<p>对于下标为 <code>i</code> 的格子，其能接的最大雨水量为两边最大高度的较小值，减去<code>i</code> 处的高度 <code>height[i]</code> 。</p>
<p>对每个下标 <code>i</code> 向两边扫描得到最大高度，时间复杂度为 <code>O(n)</code>；然后对每个下标求能接的雨水量，时间复杂度也为 <code>O(n)</code> ，总时间复杂度为 <code>O(n^2)</code> 。</p>
<p>优化：</p>
<p>1、使用动态规划更快地得到每个位置两边的最大高度。</p>
<p>创建两个长度为 <code>n</code> 的数组 <code>leftMax</code> 和 <code>rightMax</code> ，<code>leftMax[i]</code> 表示下标 <code>i</code> 及其左边位置中的最大高度，<code>rightMax[i]</code> 表示下标 <code>i</code> 及其右边位置中的最大高度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// leftMax[0] = height[0];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) leftMax[i] = height[i];</span><br><span class="line">            <span class="keyword">else</span> leftMax[i] = <span class="built_in">max</span>(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) rightMax[i] = height[i];</span><br><span class="line">            <span class="keyword">else</span> rightMax[i] = <span class="built_in">max</span>(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code> ，实际对整个数组遍历了三次</p>
<p>空间复杂度：<code>O(n)</code> ，需要创建两个长度为 <code>n</code> 的数组 <code>leftMax</code> 和 <code>rightMax</code> 。</p>
<p>2、单调栈</p>
<p>3、双指针</p>
<p>动态规划中需要维护两个数组 <code>leftMax</code> 和 <code>rightMax</code> ，空间复杂度为 <code>O(n)</code> </p>
<h1 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3 滑动窗口"></a>3 滑动窗口</h1><blockquote>
<p>参考：<a href="https://labuladong.online/algo/essential-technique/sliding-window-framework/#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88">我写了首诗，把滑动窗口算法变成了默写题</a></p>
</blockquote>
<p>滑动窗口算法主要用来解决子数组问题，如寻找符合某个条件的最长&#x2F;最短子数组。</p>
<p>通过维护一个窗口，不断滑动，更新答案。算法模板如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volid <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[right];  <span class="comment">// c 是将要移入窗口的元素</span></span><br><span class="line">        window.<span class="built_in">add</span>(c);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;</span><br><span class="line">        <span class="type">char</span> d = s[left];  <span class="comment">// d 是将要从窗口移除的元素</span></span><br><span class="line">        window.<span class="built_in">remove</span>(d);  </span><br><span class="line">        left++;  <span class="comment">// 缩小窗口</span></span><br><span class="line">        <span class="comment">// 对窗口内数据更新...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-无重复字符的最长子串"><a href="#3-1-无重复字符的最长子串" class="headerlink" title="3.1 无重复字符的最长子串"></a>3.1 无重复字符的最长子串</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：<code>for</code> 循环控制滑动窗口的左侧边界，右侧边界 <code>right</code> 逐一向右遍历元素，使用 <code>unordered_set</code> 判断是否有重复元素，有重复元素就把左边界向右移动，直至窗口内无重复元素，比较各个窗口，记录最大长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; set;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; !set.<span class="built_in">count</span>(s[right])) &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(s[right++]);</span><br><span class="line">            &#125;</span><br><span class="line">            set.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类题：</p>
<p><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<h2 id="3-2-找到字符串中所有字母异位词"><a href="#3-2-找到字符串中所有字母异位词" class="headerlink" title="3.2 找到字符串中所有字母异位词"></a>3.2 找到字符串中所有字母异位词</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：套用模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : p) need[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;  <span class="comment">// 左闭右开</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right++];</span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span> (window[c] == need[c]) valid++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (right - left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid == need.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(left);</span><br><span class="line">                <span class="type">char</span> d = s[left++];</span><br><span class="line">                <span class="keyword">if</span> (need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window[d] == need[d]) valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-子串"><a href="#4-子串" class="headerlink" title="4 子串"></a>4 子串</h1><ul>
<li>前缀和</li>
<li>优先队列：一种抽象数据类型，类似队列，其中元素按照一定优先级顺序排列，出队顺序按照优先级从高到低（或从低到高）。</li>
</ul>
<h2 id="4-1-和为-K-的子数组"><a href="#4-1-和为-K-的子数组" class="headerlink" title="4.1 和为 K 的子数组"></a>4.1 和为 K 的子数组</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：</p>
<p>1、暴力解法：枚举</p>
<p>两层 <code>for</code> 循环，先固定左侧 <code>left</code> ，然后向右移动 <code>right</code> ，直到窗口内元素相加和为 <code>k</code> ，此时计数加 1。时间复杂度 <code>O(n^2)</code> ，容易超时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力解法：枚举</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left &lt; n; left++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> right = left; right &lt; n; right++) &#123;</span><br><span class="line">                sum += nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、前缀和 + 哈希表优化</p>
<p>思路：计算前 <code>i</code> 个数的和，存储到数组中。如果前 <code>i</code> 个数的和与前 <code>j</code> 个数之和的差为 <code>k</code> （<code>0&lt;=j&lt;i</code>)，则 <code>i</code> 与 <code>j</code> 之间的子数组满足要求</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">find</span>(sum - k) != map.<span class="built_in">end</span>()) res += map[sum - k];</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-滑动窗口最大值"><a href="#4-2-滑动窗口最大值" class="headerlink" title="4.2 滑动窗口最大值"></a>4.2 滑动窗口最大值</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：对于每个滑动窗口，可以使用 <code>O(k)</code> 的时间复杂度遍历其中每个元素，找出其中最大值。对于长度为 <code>n</code> 的数组，窗口数量为 <code>n-k+1</code> ，总时间复杂度为 <code>O(n*(n-k+1))=O(n*(n-k))</code> 。</p>
<p>1、优先队列：初始时，将数组 <code>nums</code> 的前 <code>k</code> 个元素放入优先队列中，每次向右移动窗口时，将一个新元素放入优先队列中，此时堆顶元素为堆中最大值。此最大值可能在新窗口中，也可能在上一窗口的最左侧（此时需要删除该最大值，重新计算堆中最大值作为新窗口的最大值）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优先队列 prioriry_queue</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">top</span>().second &lt;= i - k) q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、单调队列</p>
<h2 id="4-3-最小覆盖子串"><a href="#4-3-最小覆盖子串" class="headerlink" title="4.3 最小覆盖子串"></a>4.3 最小覆盖子串</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：</p>
<p>1、在字符串 <code>S</code>(source) 中使用双指针寻找符合条件的 <code>T</code> (target) ，初始化 <code>left=right=0</code> ，把左闭右开的 <code>[left,right)</code> 当做窗口。</p>
<p>2、<code>right</code> 不断地右移直至窗口中元素都包含 <code>T</code> 中所有字符</p>
<p>3、然后 <code>left</code> 左移缩小窗口，直到窗口内字符串不再符合要求</p>
<p>4、重复2、3步，直到 <code>right</code> 到达字符串 <code>S</code> 的末尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// need：记录所需的字符</span></span><br><span class="line">        <span class="comment">// window：记录窗口内包含的字符</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于哈希表，使用方括号访问键对应的值 map[key]，但当 key 不存在时，</span></span><br><span class="line">        <span class="comment">// C++会自动创建该 key，并把 map[key] 赋值为 0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;  <span class="comment">// 记录 window 内符合要求的字符数</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, len = INT_MAX;  <span class="comment">// 记录最小覆盖子串起始索引及长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// right 右移，扩大滑窗，直至窗口内元素满足要求</span></span><br><span class="line">            <span class="type">char</span> c = s[right++];</span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span> (window[c] == need[c]) valid++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否要缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="comment">// 记录最小子串长度，如果当前子串长度小于之前的最小子串长度</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果最左侧要移除的元素是 need 中所需元素，导致 valid - 1，进而跳出 while 循环。</span></span><br><span class="line">                <span class="type">char</span> d = s[left++];  <span class="comment">// 将要移除的元素</span></span><br><span class="line">                <span class="keyword">if</span> (need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window[d] == need[d]) valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="5-普通数组"><a href="#5-普通数组" class="headerlink" title="5 普通数组"></a>5 普通数组</h1><h2 id="5-1-最大子数组和"><a href="#5-1-最大子数组和" class="headerlink" title="5.1 最大子数组和"></a>5.1 最大子数组和</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">53. 最大子数组和 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：</p>
<p>1、动态规划：假设 <code>nums</code> 数组长度为 <code>n</code> ，下标从 <code>0</code> 到 <code>n-1</code> 。使用 <code>f(i)</code> 表示以第 <code>i</code> 个数结尾的数组中最大的子数组和。只需求出每个 <code>f(i)</code> ，然后取最大值即可。考虑 <code>nums[i]</code> 单独成为一段或者加入 <code>f(i-1)</code> 对应的那一段，动态转移方程为 <code>f(i) = max&#123; f(i-1)+nums[i], nums[i]&#125;</code> 。（注意：不管取那一段都是以 <code>nums[i]</code> 结尾的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp = <span class="number">0</span>, res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) dp = nums[i];</span><br><span class="line">            <span class="keyword">else</span> dp = <span class="built_in">max</span>(dp + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
<p>2、分治</p>
<h2 id="5-2-合并区间"><a href="#5-2-合并区间" class="headerlink" title="5.2 合并区间"></a>5.2 合并区间</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked">56. 合并区间 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：将列表中的区间按照左端点升序排序，将第一个区间加入 res 数组，然后依次考虑后面的区间。如果当前区间左端点大于 res 数组中最后一个区间的右端点，则不合并（即添加到 res 数组中）。若小于等于，则两个区间重合，使用当前区间的右端点更新数组中最后一个区间的右端点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-轮转数组"><a href="#5-3-轮转数组" class="headerlink" title="5.3 轮转数组"></a>5.3 轮转数组</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：</p>
<p>1、使用额外的数组：<code>n</code> 表示数组长度，遍历原数组，将原数组下标为 <code>i</code> 的元素放到新数组下标为 <code>(i+k)mod n</code> 的位置，然后将新数组拷贝到原数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">assign</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());  <span class="comment">// 拷贝数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、</p>
<h2 id="5-4-除自身以外数组的乘积"><a href="#5-4-除自身以外数组的乘积" class="headerlink" title="5.4 除自身以外数组的乘积"></a>5.4 除自身以外数组的乘积</h2><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p>
</blockquote>
<p>思路：</p>
<p>1、左右乘积列表：分解问题，对于给定索引<code>i</code> ，将左边数字乘积和右边数字乘积相乘得到答案。初始化两个空数组<code>L</code> 和 <code>R</code> ，因为第一个元素左边没有元素，所以 <code>L[0]</code> 初始化为 1，<code>L[i] = L[i-1] * nums[i]</code> 。<code>R</code> 同理，索引 <code>i</code> 处的值为：<code>L[i] * R[i]</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-5-缺失的第一个正数"><a href="#5-5-缺失的第一个正数" class="headerlink" title="5.5 缺失的第一个正数"></a>5.5 缺失的第一个正数</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题记录（1）</title>
    <url>/posts/6245.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>主要使用 java 重新刷一遍代码随想录。</p>
</blockquote>
<p>2025-2-18 00:00 开始</p>
<span id="more"></span>

<p>思路：</p>
<ul>
<li>需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法</li>
<li></li>
</ul>
<h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h1><h2 id="1-1-二分查找"><a href="#1-1-二分查找" class="headerlink" title="1.1 二分查找"></a>1.1 二分查找</h2><p>有序数组、无重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[len - <span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-移除元素"><a href="#1-2-移除元素" class="headerlink" title="1.2 移除元素"></a>1.2 移除元素</h2><p>在数组中移除目标元素，然后将剩余元素往前排。（原地移除）</p>
<ul>
<li>暴力：两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</li>
<li>易错：<code>i--</code>，后面元素都向前移了一位，最外层循环 <code>i</code> 应保持不变。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j ++) nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>快慢指针（数组、链表、字符串等）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li>
<li>注意：fast 在前面找不同于 val 的元素，然后传给 slow</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; len; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-有序数组的平方"><a href="#1-3-有序数组的平方" class="headerlink" title="1.3 有序数组的平方"></a>1.3 有序数组的平方</h2><ul>
<li>先平方，再排序 O(n + nlogn)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双指针：从两头往中间收缩，比较两头元素平方的大小。取较大值填入新数组的右边界位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt;= nums[j] * nums[j]) &#123;</span><br><span class="line">                result[k] = nums[j] * nums[j];</span><br><span class="line">                k--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[k] = nums[i] * nums[i];</span><br><span class="line">                k--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-长度最小的子数组"><a href="#1-4-长度最小的子数组" class="headerlink" title="1.4 长度最小的子数组"></a>1.4 长度最小的子数组</h2><ul>
<li>滑动窗口：for循环控制窗口右边界，while循环控制窗口左边界</li>
<li>时间复杂度：O(n)</li>
<li>易错：result初始化，最后返回值，while循环逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(right - left + <span class="number">1</span>, result);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-螺旋矩阵-II"><a href="#1-5-螺旋矩阵-II" class="headerlink" title="1.5 螺旋矩阵 II"></a>1.5 螺旋矩阵 II</h2><ul>
<li>模拟：一圈一圈的填充矩阵，从顶部的左到右，最右边的上到下，底部的右到左，最左边的下到上。</li>
<li>易错：边界条件的处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>, startY = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, loop = <span class="number">1</span>, offset = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">while</span> (loop &lt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">            i = startX;</span><br><span class="line">            j = startY;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n - offset; j++) nums[i][j] = count++;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n - offset; i++) nums[i][j] = count++;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startY; j--) nums[i][j] = count++;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startX; i--) nums[i][j] = count++;</span><br><span class="line"></span><br><span class="line">            startX++;</span><br><span class="line">            startY++;</span><br><span class="line">            offset++;</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) nums[startX][startY] = count;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-区间和-（自选）"><a href="#1-6-区间和-（自选）" class="headerlink" title="1.6 区间和 （自选）"></a>1.6 区间和 （自选）</h2><ul>
<li>前缀和：重复利用计算过的子数组之和，减少计算次数</li>
<li>易错：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) sum[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sum[i] = sum[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (scan.hasNextInt()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> result;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) result = sum[b];</span><br><span class="line">            <span class="keyword">else</span> result = sum[b] - sum[a - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-开发商购买土地-（自选）"><a href="#1-7-开发商购买土地-（自选）" class="headerlink" title="1.7 开发商购买土地 （自选）"></a>1.7 开发商购买土地 （自选）</h2><h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2 链表"></a>2 链表</h1><h2 id="2-1-移除链表元素"><a href="#2-1-移除链表元素" class="headerlink" title="2.1 移除链表元素"></a>2.1 移除链表元素</h2><ul>
<li>虚拟节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur.next.val == val) cur.next = cur.next.next;</span><br><span class="line">           <span class="keyword">else</span> cur = cur.next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-设计链表"><a href="#2-2-设计链表" class="headerlink" title="2.2 设计链表"></a>2.2 设计链表</h2><ul>
<li>单链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line">        ListNode(<span class="type">int</span> val, ListNode next) &#123;<span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) cur = cur.next;</span><br><span class="line">        <span class="comment">// while (index &gt;= 0) &#123;</span></span><br><span class="line">        <span class="comment">//     cur = cur.next;</span></span><br><span class="line">        <span class="comment">//     index--;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        tmp.next = head.next;</span><br><span class="line">        head.next = tmp;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// return head;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) cur = cur.next;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; size; i++) cur = cur.next;</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) cur = cur.next;</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) cur = cur.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>双链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-翻转链表"><a href="#2-3-翻转链表" class="headerlink" title="2.3 翻转链表"></a>2.3 翻转链表</h2><ul>
<li>双指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, tmp = <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="keyword">return</span> reverse(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-两两交换链表中的节点"><a href="#2-4-两两交换链表中的节点" class="headerlink" title="2.4 两两交换链表中的节点"></a>2.4 两两交换链表中的节点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> cur.next.next;</span><br><span class="line">            cur.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            cur = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> swapPairs(next.next);</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-删除链表的倒数第-N-个结点"><a href="#2-5-删除链表的倒数第-N-个结点" class="headerlink" title="2.5 删除链表的倒数第 N 个结点"></a>2.5 删除链表的倒数第 N 个结点</h2><ul>
<li>双指针法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy, slow = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) fast = fast.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slow.next != <span class="literal">null</span>) slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-链表相交"><a href="#2-6-链表相交" class="headerlink" title="2.6 链表相交"></a>2.6 链表相交</h2><h2 id="2-7-环形链表II"><a href="#2-7-环形链表II" class="headerlink" title="2.7 环形链表II"></a>2.7 环形链表II</h2><h1 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3 哈希表"></a>3 哈希表</h1><h2 id="3-1-有效的字母异位词"><a href="#3-1-有效的字母异位词" class="headerlink" title="3.1 有效的字母异位词"></a>3.1 有效的字母异位词</h2><ul>
<li>字典解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count : record) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-两个数组的交集"><a href="#3-2-两个数组的交集" class="headerlink" title="3.2 两个数组的交集"></a>3.2 两个数组的交集</h2><ul>
<li>HashSet</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) hashSet.add(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(num)) result.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return result.stream().mapToInt(x -&gt; x).toArray();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : result) array[i++] = num;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-快乐数"><a href="#3-3-快乐数" class="headerlink" title="3.3 快乐数"></a>3.3 快乐数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !set.contains(n)) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getNextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            res += tmp * tmp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-两数之和"><a href="#3-4-两数之和" class="headerlink" title="3.4 两数之和"></a>3.4 两数之和</h2><ul>
<li>两层 for 循环</li>
<li>HashMap： key  value</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// int len = nums.length;</span></span><br><span class="line">        <span class="comment">// int[] res = new int[2];</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = i + 1; j &lt; len; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         if (nums[i] + nums[j] == target) &#123;</span></span><br><span class="line">        <span class="comment">//             res[0] = i;</span></span><br><span class="line">        <span class="comment">//             res[1] = j;  </span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(tmp)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, hashMap.get(tmp)&#125;;</span><br><span class="line">            <span class="keyword">else</span> hashMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-四数相加"><a href="#3-5-四数相加" class="headerlink" title="3.5 四数相加"></a>3.5 四数相加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums1.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">                map.put(tmp, map.getOrDefault(tmp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums3.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums4.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span> - (nums3[i] + nums4[j]);</span><br><span class="line">                res += map.getOrDefault(tmp, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-赎金信"><a href="#3-6-赎金信" class="headerlink" title="3.6 赎金信"></a>3.6 赎金信</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) count[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-三数之和"><a href="#3-7-三数之和" class="headerlink" title="3.7 三数之和"></a>3.7 三数之和</h2><ul>
<li>双指针法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-8-四数之和"><a href="#3-8-四数之和" class="headerlink" title="3.8 四数之和"></a>3.8 四数之和</h2><h1 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4 字符串"></a>4 字符串</h1><h2 id="4-1-反转字符串"><a href="#4-1-反转字符串" class="headerlink" title="4.1 反转字符串"></a>4.1 反转字符串</h2><ul>
<li>双指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = tmp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-反转字符串II"><a href="#4-2-反转字符串II" class="headerlink" title="4.2 反转字符串II"></a>4.2 反转字符串II</h2><p><code>StringBuffer</code> 是 Java 中的一个类，用于表示可变的字符序列。与 <code>String</code> 类不同，<code>StringBuffer</code> 的内容可以被修改而不创建新的对象，这使得它在需要频繁修改字符串内容的场景中非常有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-3-替换数字"><a href="#4-3-替换数字" class="headerlink" title="4.3 替换数字"></a>4.3 替换数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceNumbers</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">newSLen</span> <span class="operator">=</span> sLen + count * <span class="number">5</span>;</span><br><span class="line">        <span class="type">char</span>[] newS = <span class="keyword">new</span> <span class="title class_">char</span>[newSLen];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> newSLen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                newS[j--] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                newS[j--] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                newS[j--] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                newS[j--] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                newS[j--] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                newS[j--] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> newS[j--] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scan.next();</span><br><span class="line">        System.out.println(replaceNumbers(s));</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-反转字符串里的单词"><a href="#4-4-反转字符串里的单词" class="headerlink" title="4.4 反转字符串里的单词"></a>4.4 反转字符串里的单词</h2><h2 id="4-5-右旋转字符串"><a href="#4-5-右旋转字符串" class="headerlink" title="4.5 右旋转字符串"></a>4.5 右旋转字符串</h2><h2 id="4-6-实现-strStr"><a href="#4-6-实现-strStr" class="headerlink" title="4.6 实现 strStr"></a>4.6 实现 strStr</h2><h2 id="4-7-重复的子字符串"><a href="#4-7-重复的子字符串" class="headerlink" title="4.7 重复的子字符串"></a>4.7 重复的子字符串</h2><h1 id="5-双指针法"><a href="#5-双指针法" class="headerlink" title="5 双指针法"></a>5 双指针法</h1><h1 id="6-栈与队列"><a href="#6-栈与队列" class="headerlink" title="6 栈与队列"></a>6 栈与队列</h1><h1 id="7-二叉树"><a href="#7-二叉树" class="headerlink" title="7 二叉树"></a>7 二叉树</h1><h1 id="8-回溯算法"><a href="#8-回溯算法" class="headerlink" title="8 回溯算法"></a>8 回溯算法</h1><h1 id="9-贪心算法"><a href="#9-贪心算法" class="headerlink" title="9 贪心算法"></a>9 贪心算法</h1><h1 id="10-动态规划"><a href="#10-动态规划" class="headerlink" title="10 动态规划"></a>10 动态规划</h1><h1 id="11-单调栈"><a href="#11-单调栈" class="headerlink" title="11 单调栈"></a>11 单调栈</h1><h1 id="12-图论"><a href="#12-图论" class="headerlink" title="12 图论"></a>12 图论</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://www.programmercarl.com/">代码随想录</a></p>
</li>
<li><p><a href="https://tongyi.aliyun.com/">通义千问</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/posts/14158.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><p>地址：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
<blockquote>
<p>以下学习内容来自于 chatgpt、通义千问等大语言模型（LLMs） <a href="http://www.runoob.com/">菜鸟教程 - 学的不仅是技术，更是梦想！</a></p>
</blockquote>
<p>代码随想录：</p>
<p>第一遍完成时间：2024-3-1 ~ </p>
<h2 id="1-c"><a href="#1-c" class="headerlink" title="1 c++"></a>1 c++</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><blockquote>
<p>定义：在C++中，指针提供了直接访问内存地址的能力，允许对内存进行灵活的操作。</p>
</blockquote>
<p>1、定义指针：指针是一个变量，其存储的值是另一个变量的内存地址。可使用以下语法定义指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr; <span class="comment">// 定义一个指向整数的指针</span></span><br></pre></td></tr></table></figure>

<p>此处的 <code>*</code> 表示指针，<code>int*</code> 表示指向整数的指针。</p>
<p>2、获取地址：可以使用取地址运算符 <code>&amp;</code> 来获取变量的内存地址，并将其赋值给指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var; <span class="comment">// ptr 指向变量 var 的地址</span></span><br></pre></td></tr></table></figure>

<p>3、解引用：可以使用解引用运算符 <code>*</code> 来访问指针所指向的内存地址存储的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// value 的值为10，即 ptr 所指向的内存地址处的值</span></span><br></pre></td></tr></table></figure>

<p>4、空指针：指针可以指向空地址，表示不指向任何有效的内存位置，可以使用特殊的空指针常量 <code>nullptr</code> 来表示空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="literal">nullptr</span>; <span class="comment">// 定义一个空指针</span></span><br></pre></td></tr></table></figure>

<p>5、动态内存分配：可以使用 <code>new</code> 运算符来在堆上动态分配内存，返回分配内存的地址，并将其赋值给指针。需要记得不再使用内存时，使用 <code>delete</code> 运算符释放内存，防止内存泄露。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 在堆上动态分配一个整数的内存，并将其地址赋值给指针</span></span><br><span class="line">*ptr = <span class="number">10</span>; <span class="comment">// 向分配的内存中存储值</span></span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 释放分配的内存</span></span><br></pre></td></tr></table></figure>

<p>6、数组指针：指针也可以指向数组的首地址，这样就可以通过指针来访问数组的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = arr; <span class="comment">// 将数组的首地址赋值给指针</span></span><br></pre></td></tr></table></figure>

<p>指针数组：让数组存储指向 int 或 char 或其他数据类型的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *names[MAX] = &#123;<span class="string">&quot;Zara Ali&quot;</span>, <span class="string">&quot;Hina Ali&quot;</span>, <span class="string">&quot;Nuha Ali&quot;</span>, <span class="string">&quot;Sara Ali&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++ ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value of names[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; names[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下：</span></span><br><span class="line">Value of names[<span class="number">0</span>] = Zara Ali</span><br><span class="line">Value of names[<span class="number">1</span>] = Hina Ali</span><br><span class="line">Value of names[<span class="number">2</span>] = Nuha Ali</span><br><span class="line">Value of names[<span class="number">3</span>] = Sara Ali</span><br></pre></td></tr></table></figure>

<p><code>names</code>是一个数组，数组中每个元素都是一个指向 <code>const char</code> 类型的指针。在将字符串常量作为初始值赋值给 <code>names</code> 数组时，实际上是将这些字符串常量的首地址赋给了 <code>names数组中的指针元素。所以在循环中打印 names[i]</code> 时会输出字符串内容而不是地址。</p>
<p>7、指针的算术运算：加法、减法等，但要注意指针的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = arr;</span><br><span class="line">ptr++; <span class="comment">// 指向数组的下一个元素</span></span><br></pre></td></tr></table></figure>

<p>我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。下面的程序递增变量指针，一遍顺序访问数组中的每一个元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var[MAX] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针中的数组地址</span></span><br><span class="line">    ptr = var;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Adress of var[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value of var[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将指针移动到下一个位置</span></span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Address of var[0] = 0xbfa088b0</span><br><span class="line">Value of var[0] = 10</span><br><span class="line">Address of var[1] = 0xbfa088b4</span><br><span class="line">Value of var[1] = 100</span><br><span class="line">Address of var[2] = 0xbfa088b8</span><br><span class="line">Value of var[2] = 200</span><br></pre></td></tr></table></figure>

<p>指针的比较：指针可以用关系运算符进行比较，如 &#x3D;&#x3D;、&lt; 和 &gt; 。如果 p1 和 p2 指向两个相关的变量，例如同一个数组中的不同元素，则可以对 p1 和 p2 进行比较。</p>
<p>以上程序的另一种写法：只要变量指针所指向的地址小于等于数组最后一个元素的地址 <code>&amp;var[MAX-1]</code> ，就把变量指针进行递增：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var[MAX] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = var; <span class="comment">// 将数组中第一个元素的地址赋给指针</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt;= &amp;var[MAX - <span class="number">1</span>]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Adress of var[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value of var[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span>;</span><br><span class="line">        cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将指针移动到下一个位置</span></span><br><span class="line">        ptr++;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、指针和函数：指针可以作为函数的参数，用于传递地址，实现对函数外部变量的修改。也可以作为函数的返回值，返回指向堆上分配内存的地址。</p>
<p>C++ 允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。</p>
<p>下面的实例中，我们传递一个无符号（C++中用于描述整数类型的关键字，表示该类型的取值范围为非负整数，包括0，不包括负整数）的 long 型指针给函数，并在函数内改变这个值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写函数时应习惯性的先声明函数，再定义函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSeconds</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">getSeconds</span> (&amp;sec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出实际值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Number of seconds: &quot;</span> &lt;&lt; sec &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSeconds</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前秒数</span></span><br><span class="line">    *ptr = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、指向指针的指针：指向指针的指针是一种多级间接寻址形式，或者说是一个指针链。指针的指针就是将一个指针的地址存放到另一个指针里面。</p>
<p>通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)" alt="img"></p>
<p>一个指向指针的指针变量必须进行如下声明， 即在变量名前放置两个星号。例如，下面声明了一个指向 <code>int</code> 类型指针的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **var;    </span><br></pre></td></tr></table></figure>

<p>当一个目标值被一个指针间接指向另一个指针时，访问这个值需要使用两个星号运算符，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> **pptr;</span><br><span class="line">    </span><br><span class="line">    var = <span class="number">3000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 var 的地址</span></span><br><span class="line">    ptr = &amp;var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用运算符 &amp; 获取 ptr 的地址</span></span><br><span class="line">    pptr = &amp;ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 pptr 获取值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the value of var: &quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the value of *ptr: &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the value of **pptr: &quot;</span> &lt;&lt; **pptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：指针是C++中一个非常重要和强大的特性，它可以用于动态内存管理、数组访问、函数调用等方面，但需要谨慎使用，避免出现内存泄露和悬挂指针等问题。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><blockquote>
<p>定义：c++中的模板（Template）是一种通用编程技术，它允许程序员编写通用的代码，使其可以适用于不同的数据类型。模板可以用于函数、类、结构体等，通过模板可以实现泛型编程。</p>
</blockquote>
<p>以下是c++模板中的几种常见用法：</p>
<p>1、函数模板：允许定义通用的函数，可以用于处理不同类型的数据，定义函数模板的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span> <span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数模板 <code>add</code> 可以对两个相同类型的数据进行加法运算，无论该类型是整数、浮点数、字符串还是其他类型。 </p>
<p>2、类模板：类模板允许定义通用的类，可用于创建不同类型的对象，定义语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote>
<p>在编写代码时，经常会遇到相同的逻辑需要用于不同的数据类型，此时没有必要为每种数据类型编写单独的代码。泛型就是为了解决这个问题而提出的一种编程范式。</p>
<p>c++中，泛型编程通过模板（Template）实现，模板允许程序员编写通用的代码，使得它可以适用于不同的数据类型。</p>
</blockquote>
<p>举例：假设我们有一个函数用于交换两个整数的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapIntegers</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要交换两个浮点数或字符串，就需要重新编写一个交换函数，这样就会导致代码冗余和维护困难。</p>
<p>而使用泛型，可以定义一个通用的交换函数模板，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapIntegers</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模板中，typename T 表示我们将使用一个泛型类型 T，这个模板函数可以接受任意类型的参数 a 和 b，并交换它们的值。调用该函数时，编译器会根据传入参数的类型实例化模板，生成对应的函数版本。</p>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL（Standard Template Lubrary）是 C++ 标准库中的一个重要组成部分，提供了丰富的容器、算法和函数对象等工具，使得 C++ 变成更加高效和便捷。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p><code>vector</code> 是一种动态数组，提供了快速的随机访问和动态调整大小的能力</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个向量存储 int 类型数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用迭代器 iterator 范文值</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">        v++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>push_back() 成员函数在向量的末尾插入值，如果有必要则拓展向量的大小</li>
<li>size() 函数显示向量的大小</li>
<li>begin() 函数返回一个指向向量开头的迭代器</li>
<li>end() 函数返回一个指向向量末尾的迭代器</li>
<li>empty() 函数检查向量是否为空</li>
<li>front() 函数获取向量的第一个元素</li>
<li>back() 函数获取向量的最后一个元素</li>
<li>data() 函数返回指向向量数据的指针</li>
<li>at() 函数获取对应位置的元素</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h2 id="2-Leetcode"><a href="#2-Leetcode" class="headerlink" title="2 Leetcode"></a>2 Leetcode</h2><h3 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h3><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h4><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接(opens new window)</a></p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>思路：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<h5 id="方法一：暴力求解"><a href="#方法一：暴力求解" class="headerlink" title="方法一：暴力求解"></a>方法一：暴力求解</h5><p>两层<code>for</code> 循环，一个循环遍历数组元素，第二个循环更新数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size =  nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 因为每次进 for 都要对 i 加 1，前面删除了一个元素，</span></span><br><span class="line">                <span class="comment">// 此处 i-1 要保持下一次进入循环后还是原来的 i。</span></span><br><span class="line">                i--;  </span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n^2)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
<h5 id="方法二：双指针法（快慢指针）"><a href="#方法二：双指针法（快慢指针）" class="headerlink" title="方法二：双指针法（快慢指针）"></a>方法二：双指针法（快慢指针）</h5><p>通过一个快指针和慢指针在一个 <code>for</code> 循环中完成两个 <code>for</code> 循环的工作</p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素，新数组就是不含目标元素的数组</li>
<li>慢指针：指向更新后的新数组下标的位置</li>
</ul>
<p>删除过程：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>双指针法（快慢指针法）在数组、链表、字符串等操作中很常见</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                <span class="comment">// 未找到目标值元素时，两个指针都往后走一步</span></span><br><span class="line">                <span class="comment">// 找目标值元素时，慢指针不动，快指针继续往下走</span></span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
<p>相关题目推荐：</p>
<ul>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除排序数组中的重复项(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/move-zeroes/">283.移动零(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977.有序数组的平方(opens new window)</a></li>
</ul>
<p>Java 版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="997-有序数组的平方"><a href="#997-有序数组的平方" class="headerlink" title="997.有序数组的平方"></a>997.有序数组的平方</h4><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p>
<p><a href="https://www.programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<ul>
<li>输入：nums &#x3D; [-4,-1,0,3,10]</li>
<li>输出：[0,1,9,16,100]</li>
<li>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：nums &#x3D; [-7,-3,2,3,11]</li>
<li>输出：[4,9,9,49,121]</li>
</ul>
<h5 id="方法一：暴力求解-1"><a href="#方法一：暴力求解-1" class="headerlink" title="方法一：暴力求解"></a>方法一：暴力求解</h5><p>每个数平方之后，再排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            A[i] *= A[i];  <span class="comment">// 遍历每个数，然后平方</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()); <span class="comment">// 快速排序</span></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该方法的时间复杂度为 O(n + nlogn)，可以近似为 O(nlogn) 的时间复杂度。</p>
<h5 id="方法二：双指针法"><a href="#方法二：双指针法" class="headerlink" title="方法二：双指针法"></a>方法二：双指针法</h5><p>双指针法通常用于处理数组或链表等数据结构，这种技巧通常使用两个指针来解决问题，分别称为快指针和慢指针，它们分别在数据结构上以不同的速度移动，以达到解决问题的目的。</p>
<p>双指针法通常用于解决以下问题：</p>
<p>1、数组、链表中的搜索或遍历</p>
<p>2、数组、链表中的查找和匹配</p>
<p>3、数组、链表中的区间问题</p>
<p>双指针法分为两种类型：快慢指针、左右指针</p>
<p>本题使用左右指针，比较左右两侧数值的大小，取较大值存入新数组的最右边（以形成从小到大的排列规律）</p>
<p>暂时无法在飞书文档外展示此内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// for (int i = 0; int j = nums.size() - 1; i &lt;= j) &#123; 没有加分号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;</span><br><span class="line">                result[k--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[k--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code></p>
<p>Java 版本代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> result.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;</span><br><span class="line">                result[index--] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index--] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h4><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<ul>
<li>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</li>
<li>输出：2</li>
<li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li>
</ul>
<h5 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h5><p>两个 <code>for</code> 循环不断地寻找符合条件的子序列，时间复杂度为 <code>O(n^2)</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 储存最终的结果（最小子序列长度）</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                sum += nums[j]; <span class="comment">// 求和</span></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= s) &#123;</span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 计算子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 找到符合条件最短子序列，结束循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n^2)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
<h5 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h5><p>通过不断调整子序列的起始位置和终止位置，得到想要的结果</p>
<p>这里还是以题目中的示例来举例，s&#x3D;7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span> <span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX;  <span class="comment">// 保存最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;  <span class="comment">// 滑动窗口数值之和</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;   <span class="comment">// 滑动窗口的起始位置</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;  <span class="comment">// 滑动窗口的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            sum += nums[j];  <span class="comment">// 计算第一个元素到最后一个元素 j 的序列之和</span></span><br><span class="line">            <span class="comment">// 如果该序列和大于s，则缩减</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;  <span class="comment">// 计算子序列长度</span></span><br><span class="line">                result = result &lt; subLength ? result : subLength;  <span class="comment">// 将长度存入 result</span></span><br><span class="line">                sum -= nums[i--];  <span class="comment">// 缩减长度，同时动态调整子序列的初始位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>一些录友会疑惑为什么时间复杂度是O(n)。</p>
<p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p>
<h5 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h5><ul>
<li><p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串(opens new window)</a></p>
</li>
</ul>
<p>Java 语言版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span> <span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h4><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>示例:</p>
<p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p>
<p>面试频率较高，模拟过程，十分考察对代码的掌控能力。</p>
<p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>由外向内一圈一圈这么画下去。</p>
<p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是一进循环深似海，从此offer是路人。</p>
<p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332484.(null)" alt="img"></p>
<p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。这也是坚持了每条边左闭右开的原则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span> (<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 使用 vector 定义一个二维数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;  <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="comment">// 每个圈循环几次，例如n为奇数3，则loop=1，只循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> loop = n/<span class="number">2</span>;  </span><br><span class="line">        <span class="type">int</span> mid = n/<span class="number">2</span>;  <span class="comment">// 矩阵中间的位置，例如n为3，则中间位置为（1,1），n为5，中间位置为（2,2）</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;  <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;  <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 以下的四个for循环模拟转圈的过程</span></span><br><span class="line">            <span class="comment">// 模拟填充最上面一行，从左到右（左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟填充最右边一列，从上到下（左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟填充最下面一行，从右到左（左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟填充最左边一列，从下到上（左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要+1</span></span><br><span class="line">            <span class="comment">// 例如：第一圈起始位置为（0,0），第二圈起始位置为（1,1）</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// offset 控制每一圈每一条边遍历的长度</span></span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 n 为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n^2)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
<p>类题：</p>
<ul>
<li><a href="https://leetcode.cn/problems/spiral-matrix/">54.螺旋矩阵(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指Offer 29.顺时针打印矩阵(opens new window)</a></li>
</ul>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332586.(null)" alt="img"></p>
<h3 id="2-2-链表"><a href="#2-2-链表" class="headerlink" title="2.2 链表"></a>2.2 链表</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>链表是一种通过指针串联在一起的线性结构，每个节点由两部分组成，一个数据域（存放数据）一个指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null （空指针）。</p>
<p>链表的入口节点（头结点）为 head。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332494.(null)" alt="img"></p>
<p>双链表：每个节点有两个指针域，一个指向下一节点，一个指向上一节点。双链表既可向前查询又可向后查询。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332459.(null)" alt="img"></p>
<p>循环链表：首尾相连的链表，可以用来解决约瑟夫环问题。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332452.(null)" alt="img"></p>
<p>链表的存储方式：数组在内存中是连续分布的，链表在内存中可以不是连续分布的。链表通过指针域的指针链接在内存中各个节点，各个节点散乱分布在内存的某个地址上，分配机制取决于操作系统的内存管理。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332545.(null)" alt="img"></p>
<p>该链表起始节点为2，终止节点为7，各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p>
<h4 id="链表节点定义"><a href="#链表节点定义" class="headerlink" title="链表节点定义"></a>链表节点定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> val; <span class="comment">// 节点上存储的元素</span></span><br><span class="line">  ListNode *next;  <span class="comment">// 指向下一节点的指针</span></span><br><span class="line">  <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果在链表节点的定义中不定义构造函数，C++会默认生成一个构造函数，但该构造函数不会初始化任何成员变量，例如：</p>
<ul>
<li>通过自己定义的构造函数初始化节点：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用默认构造函数初始化节点（注意：初始化时不能直接给变量赋值）：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h4><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p>要删除 D 节点，只需要将 C 节点的 next 指针指向 E 节点就可以了。然后再手动的释放 D 节点 （释放内存），其他语言如 Java、Python 有自己的内存回收机制，不用手动释放内存。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332622.(null)" alt="img"></p>
<h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><p>添加节点类似，只需要改动指针指向即可。链表的增添和删除都是 <code>O(1)</code> 操作，不会影响其他节点。</p>
<p>但需注意：如果要删除最后一个节点，需要从头结点查找到倒数第二个节点，然后通过 next 指针进行删除操作，查找的时间复杂度是 <code>O(n)</code>。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332608.(null)" alt="img"></p>
<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332687.(null)" alt="img"></p>
<h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接(opens new window)</a></p>
<p>题意：删除链表中等于给定值 val 的所有节点。</p>
<p>示例 1： 输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6 输出：[1,2,3,4,5]</p>
<p>示例 2： 输入：head &#x3D; [], val &#x3D; 1 输出：[]</p>
<p>示例 3： 输入：head &#x3D; [7,7,7,7], val &#x3D; 7 输出：[]</p>
<p>对于单链表，如果删除头结点如何处理？</p>
<p>两种操作方式：</p>
<ul>
<li>直接使用原来的链表进行删除操作</li>
</ul>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332855.(null)" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span> <span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当链表存在且头结点的值是目标值时，删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123;</span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = tmp-&gt;next;  <span class="comment">// cur-&gt;next-&gt;next</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code>  </p>
<p>空间复杂度：<code>O(1)</code></p>
<ul>
<li>设置一个虚拟头结点进行删除操作</li>
</ul>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332784.(null)" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span> <span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head;  <span class="comment">// 将虚拟头结点指向head，方便后面的删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = tmp-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code>  </p>
<p>空间复杂度：<code>O(1)</code></p>
<h4 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a>707 设计链表</h4><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接(opens new window)</a></p>
<p>题意：</p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332842.(null)" alt="img"></p>
<ul>
<li>使用虚拟头结点，代码实现更方便。虚拟头结点通常用于简化链表操作，使得头结点和其他节点的操作一致化。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="comment">// 该构造函数的简写是 C++ 中的一种特性，称为成员初始化列表。</span></span><br><span class="line">        <span class="comment">// 在构造函数的参数列表后面使用冒号，按照成员变量的顺序列出每个成员变量，</span></span><br><span class="line">        <span class="comment">// 后面跟着该成员变量的初始化值。</span></span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化链表。无参构造函数，用于初始化 &#x27;MyLinkedList&#x27; 类的对象</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取第 index 个节点数值，如果 index 是非法数值直接返回 -1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span> <span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size - <span class="number">1</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="comment">// 只有当判断为 0 时才会跳出 while 循环，非零情况会一直循环下去</span></span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;  <span class="comment">// --index 会陷入死循环，一开始就输入 0</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，插入完成后，新插入的结点为链表的新头结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表最后添加一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="comment">// 如果index小于0，则在头部插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span> <span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// index 小于等于零时，添加新的头结点</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span> <span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<p>空间复杂度：<code>O(n)</code></p>
<h4 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206 翻转链表"></a>206 翻转链表</h4><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接(opens new window)</a></p>
<p>题意：反转一个单链表。</p>
<p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>思路：</p>
<p>直接改变链表 next 指针的指向，可以将链表直接反转，而不用定义一个新的链表。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332807.(null)" alt="img"></p>
<p>暂时无法在飞书文档外展示此内容</p>
<h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* tmp;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>:</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            tmp = cur-&gt;next;  <span class="comment">// 保存 cur 的下一个节点</span></span><br><span class="line">            cur-&gt;next = pre;  <span class="comment">// 反转链表节点指向</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><p>与双指针法类似的逻辑，当 cur 为空的时候循环结束，不断地将 cur 指向 pre 的过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span> <span class="params">(ListNode* pre, ListNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 与双指针法的初始化逻辑一直</span></span><br><span class="line">        <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">        <span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code> ，需要递归处理链表的每个节点</p>
<p>空间复杂度：<code>O(n)</code> ，递归调用了 n 层栈空间</p>
<p>（未理解）另外一种递归写法：从后往前反转指针指向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边缘条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next = <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        </span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code></p>
<p>空间复杂度：<code>O(n)</code></p>
<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24 两两交换链表中的节点"></a>24 两两交换链表中的节点</h4><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接(opens new window)</a></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332942.(null)" alt="img"></p>
<p>思路：</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332927.(null)" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例子： dummyHead(cur) -&gt; 1(tmp) -&gt; 2 -&gt; 3(tmp1) -&gt; 4 -&gt; null</span></span><br><span class="line">        <span class="comment">// dummyHead(cur) -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; null</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            ListNode* tmp1 = tmp-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur-&gt;next = tmp-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp;</span><br><span class="line">            tmp-&gt;next = tmp1;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;next-&gt;next;  <span class="comment">// cur移动两位，准备下一轮的交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code></p>
<p>空间复杂度：<code>O(1)</code></p>
<h4 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19 删除链表的倒数第 N 个节点"></a>19 删除链表的倒数第 N 个节点</h4><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接(opens new window)</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333265.(null)" alt="img"></p>
<p>思路：</p>
<h5 id="方法一：暴力遍历"><a href="#方法一：暴力遍历" class="headerlink" title="方法一：暴力遍历"></a>方法一：暴力遍历</h5><p>两次遍历，第一遍历得到链表长度 L；第二次遍历找到第 L-n+1 个节点，然后删除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span> <span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="方法二：双指针法-1"><a href="#方法二：双指针法-1" class="headerlink" title="方法二：双指针法"></a>方法二：双指针法</h5><h4 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h4><h4 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h4><h3 id="2-3-哈希表"><a href="#2-3-哈希表" class="headerlink" title="2.3 哈希表"></a>2.3 哈希表</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>哈希表（散列表）是根据关键码的值（key）而直接进行访问的数据结构，提高查找速度。哈希表中的关键码就类似于数组中的下标，因而我们可以通过关键码直接访问数据，如下：</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193332999.(null)" alt="img"></p>
<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333089.(null)" alt="img"></p>
<p>如果 hashCode 得到的数值大于哈希表的大小了，也就是大于tableSize了，怎么办呢？</p>
<p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p>
<p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p>
<p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p>
<h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h4><p>如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做<strong>哈希碰撞</strong>。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333142.(null)" alt="img"></p>
<p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p>
<h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a><strong>拉链法</strong></h5><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333183.(null)" alt="img"></p>
<p>（数据规模是dataSize， 哈希表的大小为tableSize）</p>
<p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p>
<h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a><strong>线性探测法</strong></h5><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p>
<p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了。如图所示：</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333218.(null)" alt="img"></p>
<h4 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h4><p>当我们想使用哈希法来解决问题的时候，一般会选择三种数据结构：数组、集合（set）、映射（map）</p>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>
<p>其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。</p>
<p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p>
<p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p>
<p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333279.(null)" alt="img"></p>
<p>总结：</p>
<p>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。</p>
<p>但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h4><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣题目链接(opens new window)</a></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p>
<p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p>
<p>说明: 你可以假设字符串只包含小写字母。</p>
<h5 id="方法一：暴力求解-2"><a href="#方法一：暴力求解-2" class="headerlink" title="方法一：暴力求解"></a>方法一：暴力求解</h5><p>两层 for 循环，同时要记录字符是否重复出现，时间复杂度 <code>O(n^2)</code></p>
<h5 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h5><p>t 是 sss 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 sss 和 ttt 分别排序，看排序后的字符串是否相等即可判断。此外，如果 sss 和 ttt 的长度不同，ttt 必然不是 sss 的异位词。</p>
<p>作者：<a href="https://leetcode.cn/problems/valid-anagram/solutions/493231/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/">力扣官方题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span> <span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：排序的时间复杂度为 <code>O(nlogn)</code> ，比较两个字符串是否相等时间复杂度为 <code>O(n)</code> ，总体时间复杂度为 <code>O(nlogn+n)=O(nlogn)</code> 。</p>
<p>空间复杂度：<code>O(logn)</code></p>
<h5 id="方法三：哈希表-（需要重点掌握）"><a href="#方法三：哈希表-（需要重点掌握）" class="headerlink" title="方法三：哈希表 （需要重点掌握）"></a>方法三：哈希表 （需要重点掌握）</h5><p>定义一个 record 数组用来记录字符串 s 中字符出现的次数，需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p>
<p>在遍历字符串 s 的时候，<strong>只需要将 s[i] - ‘a’ 所在的元素做 +1 操作即可</strong>，并不需要记住字符 a 的ASCII，只要求出一个相对数值就可以了。</p>
<p>那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，<strong>对t中出现的字符映射哈希表索引上的数值再做-1的操作。</strong></p>
<p>那么<strong>最后检查一下，record数组如果有的元素不为零</strong>，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。</p>
<p>最后<strong>如果record数组所有元素都为零，说明字符串s和t是字母异位词</strong>，return true。</p>
<p>时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span> <span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;  <span class="comment">// ASCII 码值相减即为下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Java 版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span> <span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count:record) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349 两个数组的交集"></a>349 两个数组的交集</h4><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接(opens new window)</a></p>
<p>题意：给定两个数组，编写一个函数来计算它们的交集。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333493.(null)" alt="img"></p>
<p>练习本道题目掌握 unordered_set 这一数据结构。</p>
<p>注意：输出结果中每一个元素是唯一的，需要去除重复的元素，可以不考虑输出结果的顺序。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333531.(null)" alt="img"></p>
<ul>
<li>unordered_set：基于哈希表实现，具有常数时间复杂度的查找操作，可以快速确定元素是否存在于集合中。另外它还可以自动去除重复的元素，具有更好的性能。</li>
<li>引用传递参数：如果不使用引用传递参数，而直接传递 vector 对象，会触发一次复制构造函数的调用，将原始 vector 复制一份传递给函数，在处理大型 vector 时会消耗大量的时间和内存。通过引用传递参数，函数可以直接修改原始的 vector 对象，而不需要返回值来传递修改后的结果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;  <span class="comment">// 定义无序集合，用于存储两个输入向量的交集</span></span><br><span class="line">        <span class="comment">// 使用 nums1.begin() 和 nums1.end() 作为参数传递给 unordered_set 的构造函数</span></span><br><span class="line">        <span class="comment">// 这里的 begin() 和 end() 是 vector&lt;int&gt; 类型的成员函数，</span></span><br><span class="line">        <span class="comment">// 用于返回指向 nums1 向量的第一个元素和最后一个元素之后的位置的迭代器。</span></span><br><span class="line">        <span class="comment">// nums_set 对象被初始化为包含从 nums1.begin() 到 nums1.end() 范围内的所有唯一元素的无序集合。</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 遍历 nums2 中每一个元素，判断当前遍历元素 num 是否在 nums1 中存在</span></span><br><span class="line">            <span class="comment">// find() 返回一个迭代器：如何查找元素存在，则返回一个指向该元素的迭代器。</span></span><br><span class="line">            <span class="comment">// 否则，返回指向集合尾部的迭代器，通常使用 unordered_set.end() 表示</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n+m)</code> ，m 是最后将 set 转为 vector</p>
<p>空间复杂度：<code>O(n)</code> </p>
<p>使用数组来做哈希表（条件：元素的值有范围，不能太大）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h4><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接(opens new window)</a></p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19</p>
<p>输出：true</p>
<p>解释：</p>
<p>1^2 + 9^2 &#x3D; 82</p>
<p>8^2 + 2^2 &#x3D; 68</p>
<p>6^2 + 8^2 &#x3D; 100</p>
<p>1^2 + 0^2 + 0^2 &#x3D; 1</p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>求和的时候，sum 的值可能会重复出现，所以需要快速判断一个元素是否在集合中，考虑使用哈希法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 计算一个数各个位置上数字的平方和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span> <span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span> <span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果该 sum 曾经出现过，说明已经进入了无限循环，立即退出</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(logn)</li>
<li>空间复杂度: O(logn)</li>
</ul>
<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p>
<p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p>
<p>所以返回 [0, 1]</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>1、暴力求解：两层 for 循环查找，时间复杂度为 <code>O(n^2)</code></p>
<p>2、map</p>
<p>再来看一下使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
</ul>
<p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>
<p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N)O(N) 降低到 O(1)O(1)O(1)。</p>
<p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>
<p>作者：力扣官方题解</p>
<p>链接：<a href="https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/">https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/</a></p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</p>
<p>C++中map，有三种类型：</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// auto 关键字用于自动推断变量的类型</span></span><br><span class="line">            <span class="comment">// 通过 auto 关键字，编译器会根据 hashtable.find(target - nums[i]) 返回的类型</span></span><br><span class="line">            <span class="comment">// 自动推断 it 的类型为哈希表的迭代器类型，而无需显式地指定其类型。</span></span><br><span class="line">            <span class="keyword">auto</span> iter = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h4 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454 四数相加II"></a>454 四数相加II</h4><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接(opens new window)</a></p>
<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p>
<p>例如:</p>
<p>输入:</p>
<ul>
<li>A &#x3D; [ 1, 2]</li>
<li>B &#x3D; [-2,-1]</li>
<li>C &#x3D; [-1, 2]</li>
<li>D &#x3D; [ 0, 2]</li>
</ul>
<p>输出:</p>
<p>2</p>
<p>解释:</p>
<p>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li>
</ol>
<p>思路与算法</p>
<p>我们可以将四个数组分成两部分，AAA 和 BBB 为一组，CCC 和 DDD 为另外一组。</p>
<p>对于 AAA 和 BBB，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j]A[i]+B[j]A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]A[i]+B[j]A[i]+B[j]，对应的值为 A[i]+B[j]A[i]+B[j]A[i]+B[j] 出现的次数。</p>
<p>对于 CCC 和 DDD，我们同样使用二重循环对它们进行遍历。当遍历到 C[k]+D[l]C[k]+D[l]C[k]+D[l] 时，如果 −(C[k]+D[l])-(C[k]+D[l])−(C[k]+D[l]) 出现在哈希映射中，那么将 −(C[k]+D[l])-(C[k]+D[l])−(C[k]+D[l]) 对应的值累加进答案中。</p>
<p>最终即可得到满足 A[i]+B[j]+C[k]+D[l]&#x3D;0A[i]+B[j]+C[k]+D[l]&#x3D;0A[i]+B[j]+C[k]+D[l]&#x3D;0 的四元组数目。</p>
<p>作者：力扣官方题解</p>
<p>链接：<a href="https://leetcode.cn/problems/4sum-ii/solutions/499745/si-shu-xiang-jia-ii-by-leetcode-solution/">https://leetcode.cn/problems/4sum-ii/solutions/499745/si-shu-xiang-jia-ii-by-leetcode-solution/</a></p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; countAB;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : nums2) &#123;</span><br><span class="line">                countAB[a + b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d : nums4) &#123;</span><br><span class="line">                <span class="keyword">if</span> (countAB.<span class="built_in">find</span>(<span class="number">0</span> - (c + d)) != countAB.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += countAB[<span class="number">0</span> - (c + d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</li>
</ul>
<h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383 赎金信"></a>383 赎金信</h4><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接(opens new window)</a></p>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p>注意：</p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false</p>
<p>canConstruct(“aa”, “ab”) -&gt; false</p>
<p>canConstruct(“aa”, “aab”) -&gt; true</p>
<h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><p>两层 for 循环，不断的寻找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span> <span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (magazine[i] == ransomNote[j]) &#123;</span><br><span class="line">                    ransomeNote.<span class="built_in">erase</span>(ransomNote.<span class="built_in">begin</span>() + j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p>题目中说只有小写字母，可以采用空间换时间的哈希策略，用一个长度为 26 的数组来记录 magazine 中字母出现的次数。然后再使用 ransomNote 去验证该数组中是否包含了其所需的所有字母。（相比较于使用 map，在数据量大的时候，map空间消耗更大一些。）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码随想录</span></span><br><span class="line">        <span class="comment">// int record[26] = &#123;0&#125;;</span></span><br><span class="line">        <span class="comment">// if (ransomNote.size() &gt; magazine.size()) &#123;</span></span><br><span class="line">        <span class="comment">//     return false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; magazine.size(); i++) &#123;</span></span><br><span class="line">        <span class="comment">//     record[magazine[i] - &#x27;a&#x27;]++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for (int j = 0; j &lt; ransomNote.size(); j++) &#123;</span></span><br><span class="line">        <span class="comment">//     record[ransomNote[j] - &#x27;a&#x27;]--;</span></span><br><span class="line">        <span class="comment">//     if (record[ransomNote[j] - &#x27;a&#x27;] &lt; 0) &#123;</span></span><br><span class="line">        <span class="comment">//         return false;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// leetcode 官方题解</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="comment">// auto 关键字用于自动类型推断</span></span><br><span class="line">        <span class="comment">// auto&amp; 自动推断并创建一个引用变量 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : magazine) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : ransomNote) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接(opens new window)</a></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意： 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h5 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span> (vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针"></a>排序+双指针</h5><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><h3 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4 字符串"></a>2.4 字符串</h3><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344 反转字符串"></a>344 反转字符串</h4><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：</p>
<p>输入：[“h”,”e”,”l”,”l”,”o”]</p>
<p>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p>示例 2：</p>
<p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]</p>
<p>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<p>分析：与之前反转链表的思路一样，使用双指针的方法</p>
<p>暂时无法在飞书文档外展示此内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span> <span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>()<span class="number">-1</span>; i &lt; s.<span class="built_in">size</span>()/<span class="number">2</span>; i++,j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h4 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541 反转字符串II"></a>541 反转字符串II</h4><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2</p>
<p>输出: “bacdfeg”</p>
<p>分析：按照题目意思，反转每个下标从 2k的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + <span class="built_in">min</span>(i + k, n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h4><p><a href="https://kamacoder.com/problempage.php?pid=1064">卡码网题目链接(opens new window)</a></p>
<p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p>
<p>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p>
<p>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”</p>
<p>输入：一个字符串 s,s 仅包含小写字母和数字字符。</p>
<p>输出：打印一个新的字符串，其中每个数字字符都被替换为了number</p>
<p>样例输入：a1b2c3</p>
<p>样例输出：anumberbnumbercnumber</p>
<p>数据范围：1 &lt;&#x3D; s.length &lt; 10000。</p>
<p>思路：（java 中的 string 不能修改，本题需要使用额外的辅助空间）</p>
<p>双指针法一步步填充：<code>i</code> 指向新长度的末尾，<code>j</code> 指向旧长度的末尾。</p>
<p>很多数组填充类问题，都是预先给数组扩容到填充的大小，然后在从后向前进行操作。优点：</p>
<ul>
<li>不用申请新数组。</li>
<li>从后向前填充元素，避免了从前向后填充元素时，要把添加元素之后的所有元素都向后移动的问题。</li>
</ul>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333471.(null)" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sOldSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算扩充字符串后 s 的大小，然后重构 s</span></span><br><span class="line">        s.<span class="built_in">resize</span>(sOldSize + count * <span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从后向前将空格替换为 number</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt; <span class="string">&#x27;9&#x27;</span> || s[j] &lt; <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">3</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">4</span>] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">5</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">                i -= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>双指针题目汇总：</p>
<ul>
<li><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">27.移除元素(opens new window)</a></li>
<li><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和(opens new window)</a></li>
<li><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18.四数之和(opens new window)</a></li>
<li><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.翻转链表(opens new window)</a></li>
<li><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">142.环形链表II(opens new window)</a></li>
<li><a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串(opens new window)</a></li>
</ul>
<p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组。在 C++ 中，提供一个 string 类，该类会提供一个 size 接口，可以用来判断 string 类字符串是否结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否结束</span></span><br><span class="line">string a = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vector&lt;char&gt;</code> 和 <code>string</code> 在基本操作上没区别，但 <code>string</code> 会提供更多的字符串的处理接口。</p>
<h4 id="151-反转字符串里的单词"><a href="#151-反转字符串里的单词" class="headerlink" title="151 反转字符串里的单词"></a>151 反转字符串里的单词</h4><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”</p>
<p>输出: “blue is sky the”</p>
<p>示例 2：</p>
<p>输入: “  hello world!  “</p>
<p>输出: “world! hello”</p>
<p>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：</p>
<p>输入: “a good   example”</p>
<p>输出: “example good a”</p>
<p>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>思路：</p>
<ul>
<li>简单：使用 <code>split</code> 库函数，分隔单词，然后定义新的 <code>string</code> 字符串，最后倒序相加</li>
<li>进阶：（要求不能使用辅助空间，空间复杂度要求为 <code>O(1)</code>）</li>
<li>方法：移除多余空格、将整个字符串反转、将每个单词反转</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="右旋转字符串"><a href="#右旋转字符串" class="headerlink" title="右旋转字符串"></a>右旋转字符串</h4><h4 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h4><h4 id="重复的字符串"><a href="#重复的字符串" class="headerlink" title="重复的字符串"></a>重复的字符串</h4><h3 id="2-5-双指针法"><a href="#2-5-双指针法" class="headerlink" title="2.5 双指针法"></a>2.5 双指针法</h3><h3 id="2-6-栈与队列"><a href="#2-6-栈与队列" class="headerlink" title="2.6 栈与队列"></a>2.6 栈与队列</h3><p>GPT</p>
<p>队列（Queue）</p>
<p>原理：</p>
<ul>
<li>队列是一种先进先出（FIFO，First In First Out）的数据结构，类似于现实生活中排队的场景，先到先服务。</li>
<li>在队列中，元素从队列的一端（称为队尾）添加，从另一端（称为队首）移除。</li>
<li>新的元素总是被添加到队列的末尾，而最老的元素总是在队列的开头。</li>
</ul>
<p>用法：</p>
<ul>
<li>队列常用于模拟排队、任务调度、广度优先搜索（BFS）等场景。</li>
<li>实现队列通常有两种方式：基于数组实现的顺序队列和基于链表实现的链式队列。</li>
<li>在C++中，可以使用<code>std::queue</code>模板类来实现队列，其提供了队列的常用操作，如入队、出队、查看队首元素等。</li>
</ul>
<p>栈（Stack）</p>
<p>原理：</p>
<ul>
<li>栈是一种后进先出（LIFO，Last In First Out）的数据结构，类似于一摞盘子，最后放上去的盘子最先被取走。</li>
<li>在栈中，元素的添加和删除操作只能在栈顶进行。</li>
<li>新的元素总是被添加到栈顶，而最新添加的元素总是在栈顶，最老的元素在栈底。</li>
</ul>
<p>用法：</p>
<ul>
<li>栈常用于递归函数调用、表达式求值、括号匹配、深度优先搜索（DFS）等场景。</li>
<li>实现栈通常有两种方式：基于数组实现的顺序栈和基于链表实现的链式栈。</li>
<li>在C++中，可以使用<code>std::stack</code>模板类来实现栈，其提供了栈的常用操作，如入栈、出栈、查看栈顶元素等。</li>
</ul>
<p>一些常见的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个队列</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 访问队首元素</span></span><br><span class="line">        p.<span class="built_in">pop</span>();  <span class="comment">// 移除队首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理：对栈也有类似的操作</p>
<p>push()：入栈操作</p>
<p>empty(): 判断栈内元素是否为空</p>
<p>top(): 访问栈顶元素</p>
<p>pop(): 移除栈顶元素</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>队列是先进先出，栈是先进后出。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333432.(null)" alt="img"></p>
<ol>
<li>C++中stack 是容器么？</li>
<li>我们使用的stack是属于哪个版本的STL？</li>
<li>我们使用的STL中stack是如何实现的？</li>
<li>stack 提供迭代器来遍历stack空间么？</li>
</ol>
<p>首先大家要知道 栈和队列是STL（C++标准库）里面的两个数据结构。</p>
<p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p>
<p>那么来介绍一下，三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
<p>接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。</p>
<p>栈先进后出，如图所示：</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333592.(null)" alt="img"></p>
<p>栈提供 push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p>
<p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</p>
<p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p>那么问题来了，STL 中栈是用什么容器实现的？</p>
<p>从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p>
<p><img src="/Users/sebas/Documents/wzq11011.github.io/source/_posts/leetcode.assets/(null)-20240417193333661.(null)" alt="img"></p>
<p>我们常用的<strong>SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构</strong>。</p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</p>
<p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; third;  <span class="comment">// 使用 vector 为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。</p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span> third; // 定义以list为底层容器的队列</span><br></pre></td></tr></table></figure>

<p>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<h3 id="2-7-二叉树"><a href="#2-7-二叉树" class="headerlink" title="2.7 二叉树"></a>2.7 二叉树</h3><h3 id="2-8-回溯算法"><a href="#2-8-回溯算法" class="headerlink" title="2.8 回溯算法"></a>2.8 回溯算法</h3><h3 id="2-9-贪心算法"><a href="#2-9-贪心算法" class="headerlink" title="2.9 贪心算法"></a>2.9 贪心算法</h3><h3 id="2-10-动态规划"><a href="#2-10-动态规划" class="headerlink" title="2.10 动态规划"></a>2.10 动态规划</h3><h3 id="2-11-单调栈"><a href="#2-11-单调栈" class="headerlink" title="2.11 单调栈"></a>2.11 单调栈</h3><h3 id="2-12-图论"><a href="#2-12-图论" class="headerlink" title="2.12 图论"></a>2.12 图论</h3><h2 id="3-牛客网"><a href="#3-牛客网" class="headerlink" title="3 牛客网"></a>3 牛客网</h2><h2 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4 其他问题"></a>4 其他问题</h2><h3 id="ACM模型"><a href="#ACM模型" class="headerlink" title="ACM模型"></a>ACM模型</h3><p>在 Leetcode 上刷题，采用的是核心代码模型。而很多公司的笔试题和面试题都是 ACM 模型，即需要自己处理数据的输入输出。</p>
<p>练习地址：<a href="https://kamacoder.com/problemset.php?page=1">卡码网KamaCoder</a></p>
<p>题解地址：<a href="https://github.com/youngyangyang04/kamacoder-solutions">GitHub - youngyangyang04&#x2F;kamacoder-solutions: 卡码网题解全集</a></p>
<p>使用git提交代码：<a href="https://www.programmercarl.com/qita/join.html">如何在Github上提交PR(pull request) | 代码随想录</a></p>
<h2 id="5-刷题记录"><a href="#5-刷题记录" class="headerlink" title="5 刷题记录"></a>5 刷题记录</h2><p>回溯</p>
<p>贪心</p>
<p>分治</p>
<p>动态规划：</p>
<p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a>   （2024-4-11 20:31）</p>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a>（2024-4-11 20:31）</p>
<h2 id="6-面试高频考点"><a href="#6-面试高频考点" class="headerlink" title="6 面试高频考点"></a>6 面试高频考点</h2><blockquote>
<p>参考：<a href="https://interviewguide.cn/notes/03-hunting_job/03-algorithm/04-high_frquency_algorithm/01-high_frquency_algorithm.html#_12%E3%80%81top-k%E9%97%AE%E9%A2%98">面试高频算法真题</a></p>
</blockquote>
<h3 id="6-1-排序算法"><a href="#6-1-排序算法" class="headerlink" title="6.1 排序算法"></a>6.1 排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>nerf-slam</title>
    <url>/posts/22247.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nerf-SLAM"><a href="#Nerf-SLAM" class="headerlink" title="Nerf-SLAM"></a>Nerf-SLAM</h1><h2 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1 配置环境"></a>1 配置环境</h2><h3 id="1-1-Ubuntu-Clash-终端代理"><a href="#1-1-Ubuntu-Clash-终端代理" class="headerlink" title="1.1 Ubuntu Clash 终端代理"></a>1.1 Ubuntu Clash 终端代理</h3><p>clash 选择节点并调整为 global 模式，在 ~&#x2F;.bashrc 中添加以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:7890 </span><br><span class="line">export http_proxy=http://127.0.0.1:7890 </span><br><span class="line">export all_proxy=socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>保存文件，并更新文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试终端是否代理</span></span><br><span class="line">curl cip.cc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示香港的节点，则代表成功</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-Install-nerf-slam"><a href="#1-2-Install-nerf-slam" class="headerlink" title="1.2 Install nerf-slam"></a>1.2 Install nerf-slam</h3><p>项目地址：<a href="https://github.com/ToniRV/NeRF-SLAM">ToniRV&#x2F;NeRF-SLAM: NeRF-SLAM: Real-Time Dense Monocular SLAM with Neural Radiance Fields. https://arxiv.org/abs/2210.13641 + Sigma-Fusion: Probabilistic Volumetric Fusion for Dense Monocular SLAM https://arxiv.org/abs/2210.01276 (github.com)</a></p>
<p>使用 git 拉取项目代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ToniRV/NeRF-SLAM.git --recurse-submodules</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>



<p>使用 conda 创建一个虚拟环境，防止污染其他环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 nerf-slam 的虚拟环境</span></span><br><span class="line">conda create -n nerf-slam</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有虚拟环境</span></span><br><span class="line">conda env list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入创建的虚拟环境</span></span><br><span class="line">conda activate nerf-slam</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install torch (CUDA 11.3)</span></span><br><span class="line">pip install torch==1.12.1+cu113 torchvision==0.13.1+cu113 --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></table></figure>

<p>使用 pip 安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装第三方库 gtsam 所需的依赖</span></span><br><span class="line">pip install -r ./thirdparty/gtsam/python/requirements.txt</span><br></pre></td></tr></table></figure>

<h3 id="1-3-编译-ngp"><a href="#1-3-编译-ngp" class="headerlink" title="1.3 编译 ngp"></a>1.3 编译 ngp</h3><p>官方教程：（cmake 版本需要大于 3.22）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install cmake</span><br><span class="line">cmake ./thirdparty/instant-ngp -B build_ngp</span><br><span class="line">cmake --build build_ngp --config RelWithDebInfo -j</span><br></pre></td></tr></table></figure>

<p>实操：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nerf-slam 环境下，安装最新版 cmake</span></span><br><span class="line">conda install cmake</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NeRF-SLAM 目录下</span></span><br><span class="line">mkdir build_ngp &amp;&amp; cd build_ngp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 ngp</span></span><br><span class="line">cmake ../thirdparty/instant-ngp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错 1：randr headers not found;install libxrandr</span></span><br><span class="line">sudo apt install libxrandr-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错 2：Xinerama headers not found; install libxinerama development package</span></span><br><span class="line">sudo apt install libxinerama-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错 3：Xcursor headers not found; install libxcursor development package</span></span><br><span class="line">sudo apt install libxcursor-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错 4：Could NOT find GLEW (missing: GLEW_INCLUDE_DIRS GLEW_LIBRARIES)</span></span><br><span class="line">sudo apt install libglew-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">到这一步基本没问题了</span></span><br><span class="line">cd ..</span><br><span class="line">cmake --build build_ngp --config RelWithDebInfo -j</span><br></pre></td></tr></table></figure>



<p>按以上步骤操作，最后运行demo.py会报 pyngp 错误，使用另一个分支解决</p>
<p>报错信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">self.ngp = ngp.Testbed(mode, 0) # NGP can only use device = 0</span><br><span class="line">TypeError: __init__(): incompatible constructor arguments. The following argument types are supported:</span><br><span class="line">    1. pyngp.Testbed(arg0: pyngp.TestbedMode)</span><br><span class="line">    2. pyngp.Testbed(arg0: pyngp.TestbedMode, arg1: str, arg2: str)</span><br><span class="line">    3. pyngp.Testbed(arg0: pyngp.TestbedMode, arg1: str, arg2: json)</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除原 instant-ngp</span></span><br><span class="line">cd thirdparty</span><br><span class="line">rm -rf instant-ngp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">地址：https://github.com/ToniRV/instant-ngp/tree/feature/nerf_slam</span></span><br><span class="line">git clone https://github.com/ToniRV/instant-ngp.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">sudo apt-get install build-essential git python3-dev python3-pip libopenexr-dev libxi-dev libglfw3-dev libglew-dev libomp-dev libxinerama-dev libxcursor-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NeRF-SLAM/</span></span><br><span class="line">mkdir build_ngp &amp;&amp; cd build_ngp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 ngp</span></span><br><span class="line">cmake ../thirdparty/instant-ngp</span><br><span class="line">cd ..</span><br><span class="line">cmake --build build_ngp --config RelWithDebInfo -j</span><br></pre></td></tr></table></figure>



<h3 id="1-4-编译-gtsam"><a href="#1-4-编译-gtsam" class="headerlink" title="1.4 编译 gtsam"></a>1.4 编译 gtsam</h3><p>官方教程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake ./thirdparty/gtsam -DGTSAM_BUILD_PYTHON=1 -B build_gtsam </span><br><span class="line">cmake --build build_gtsam --config RelWithDebInfo -j</span><br><span class="line">cd build_gtsam</span><br><span class="line">make python-install</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>



<p>实操：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建编译目录</span></span><br><span class="line">mkdir build_gtsam &amp;&amp; cd build_gtsam</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 gtsam</span></span><br><span class="line">cmake ../thirdparty/gtsam -DGTSAM_BUILD_PYTHON=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错 1：Missing required Boost components &gt;= v1.65, please install/upgrade Boost or configure your search paths.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方式 1： 创建 software，下载 boost 1.65.1 压缩包，解压编译安装</span></span><br><span class="line">cd ..</span><br><span class="line">mkdir software &amp;&amp; cd software</span><br><span class="line">wget https://boostorg.jfrog.io/artifactory/main/release/1.65.1/source/boost_1_65_1.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方法 2：直接使用 apt 命令安装</span></span><br><span class="line">conda install boost</span><br><span class="line"></span><br><span class="line">cmake --build build_gtsam --config RelWithDebInfo -j</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错 ：ModuleNotFoundError: No module named <span class="string">&#x27;pyparsing&#x27;</span></span></span><br><span class="line">conda install pyparsing</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决：https://github.com/ToniRV/NeRF-SLAM/issues/23</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gtsam 安装 （gtsam &gt; 4.0.3）</span></span><br><span class="line">cd software</span><br><span class="line">wget https://github.com/borglab/gtsam/archive/refs/tags/4.1.0.tar.gz</span><br><span class="line">tar -xzvf 4.1.0.tar.gz</span><br><span class="line">cd gtsam-4.1.0</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译，加入参数无TBB编译</span></span><br><span class="line">cmake .. -DGTSAM_BUILD_PYTHON=1 -DGTSAM_PYTHON_VERSION=3.10.11 -DGTSAM_WITH_TBB=OFF</span><br><span class="line"></span><br><span class="line">make python-install</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Install:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>



<p>增加虚拟内存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bs 单位：1024*1024*1024=1073741824</span></span><br><span class="line">sudo dd if=/dev/zero of=swapfile bs=1024 count=96000000</span><br><span class="line">sudo dd if=/dev/zero of=swapfile bs=1073741824 count=48</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把空间格式化为 swap</span> </span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用创建的 swap 空间</span></span><br><span class="line">chmod 0600 /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">释放空间</span></span><br><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>







<h3 id="1-5-下载样本数据集"><a href="#1-5-下载样本数据集" class="headerlink" title="1.5 下载样本数据集"></a>1.5 下载样本数据集</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载数据集</span></span><br><span class="line">./scripts/download_replica_sample.bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令</span></span><br><span class="line">python ./examples/slam_demo.py --dataset_dir=./datasets/Replica/office0 --dataset_name=nerf --buffer=100 --slam --parallel_run --img_stride=2 --fusion=&#x27;nerf&#x27; --multi_gpu --gui</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错：AttributeError: <span class="built_in">type</span> object <span class="string">&#x27;gtsam.gtsam.Pose3&#x27;</span> has no attribute <span class="string">&#x27;identity&#x27;</span>. Did you mean: <span class="string">&#x27;Identity&#x27;</span>?</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以更改参数 <code>--fusion=&#39;sigma&#39;</code> 来运行实现 Sigma-Fusion ，论文地址：<a href="https://arxiv.org/abs/2210.01276">https://arxiv.org/abs/2210.01276</a></p>
<h3 id="1-6-监控-GPU"><a href="#1-6-监控-GPU" class="headerlink" title="1.6 监控 GPU"></a>1.6 监控 GPU</h3><h3 id="1-7-X11"><a href="#1-7-X11" class="headerlink" title="1.7 X11"></a>1.7 X11</h3><p>报错信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">03:47:17 ERROR    GLFW error #65544: X11: The DISPLAY environment variable is missing</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果以上配置仍然出现问题，可按对应问题在 Issues 里面寻找解决方案，或者也可以尝试后面第二节给出的配置流程（亲测：Titan X 显存不足，A6000 可以跑）</p>
</blockquote>
<h1 id="2-jrpowers-x2F-NeRF-SLAM"><a href="#2-jrpowers-x2F-NeRF-SLAM" class="headerlink" title="2 jrpowers&#x2F;NeRF-SLAM"></a>2 <a href="https://github.com/jrpowers">jrpowers</a>&#x2F;<strong><a href="https://github.com/jrpowers/NeRF-SLAM">NeRF-SLAM</a></strong></h1><h2 id="2-1-Install"><a href="#2-1-Install" class="headerlink" title="2.1 Install"></a>2.1 Install</h2><p><a href="https://github.com/jrpowers/NeRF-SLAM">jrpowers&#x2F;NeRF-SLAM: Real-Time Dense Monocular SLAM with Neural Radiance Fields. https://arxiv.org/abs/2210.13641 + Sigma-Fusion: Probabilistic Volumetric Fusion for Dense Monocular SLAM https://arxiv.org/abs/2210.01276 (github.com)</a></p>
<p>Clone repo with submodules:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jrpowers/NeRF-SLAM.git --recurse-submodules</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">cd thirdparty/instant-ngp/ &amp;&amp; git checkout feature/nerf_slam</span><br></pre></td></tr></table></figure>



<h2 id="2-2-Install-CUDA-11-7-and-Pytorch"><a href="#2-2-Install-CUDA-11-7-and-Pytorch" class="headerlink" title="2.2 Install CUDA 11.7 and Pytorch"></a>2.2 Install CUDA 11.7 and Pytorch</h2><p>Use a virtual environment</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n nerf-slam</span><br><span class="line">conda activate nerf-slam</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CUDA</span></span><br><span class="line">conda install -c &quot;nvidia/label/cuda-11.7.0&quot; cuda-toolkit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pytorch</span></span><br><span class="line">conda install python==3.7</span><br><span class="line">pip install torch==1.13.1+cu117 torchvision==0.14.1+cu117 --extra-index-url https://download.pytorch.org/whl/cu117</span><br></pre></td></tr></table></figure>



<h2 id="2-3-Pip-install-requirements"><a href="#2-3-Pip-install-requirements" class="headerlink" title="2.3 Pip install requirements"></a>2.3 Pip install requirements</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install -r ./thirdparty/gtsam/python/requirements.txt</span><br></pre></td></tr></table></figure>



<h2 id="2-4-Compile-ngp-cmake-gt-3-22"><a href="#2-4-Compile-ngp-cmake-gt-3-22" class="headerlink" title="2.4 Compile ngp(cmake&gt;3.22)"></a>2.4 Compile ngp(cmake&gt;3.22)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原版ngp会报错，该分支解决问题</span></span><br><span class="line">cd thirdparty/instant-ngp/ &amp;&amp; git checkout feature/nerf_slam</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NeRF-SLAM 目录下</span></span><br><span class="line">mkdir build_ngp &amp;&amp; cd build_ngp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 ngp</span></span><br><span class="line">cmake ../thirdparty/instant-ngp</span><br><span class="line">cd ..</span><br><span class="line">cmake --build build_ngp --config RelWithDebInfo -j</span><br></pre></td></tr></table></figure>



<h2 id="2-5-Compile-gtsam-and-enable-the-python-wrapper"><a href="#2-5-Compile-gtsam-and-enable-the-python-wrapper" class="headerlink" title="2.5 Compile gtsam and enable the python wrapper"></a>2.5 Compile gtsam and enable the python wrapper</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建编译目录</span></span><br><span class="line">mkdir build_gtsam &amp;&amp; cd build_gtsam</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 gtsam</span></span><br><span class="line">cmake ../thirdparty/gtsam -DGTSAM_BUILD_PYTHON=1</span><br><span class="line">cd ..</span><br><span class="line">cmake --build build_gtsam --config RelWithDebInfo -j</span><br><span class="line">cd build_gtsam</span><br><span class="line">make python-install</span><br></pre></td></tr></table></figure>



<h2 id="2-6-Run"><a href="#2-6-Run" class="headerlink" title="2.6 Run"></a>2.6 Run</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install</span></span><br><span class="line">python setup.py install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Download Sample Data</span></span><br><span class="line">./scripts/download_replica_sample.bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run the <span class="built_in">command</span> or run.sh</span></span><br><span class="line">python ./examples/slam_demo.py --dataset_dir=./datasets/Replica/office0 --dataset_name=nerf --buffer=100 --slam --parallel_run --img_stride=2 --fusion=&#x27;nerf&#x27; --multi_gpu --gui</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure>











]]></content>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>sketch recognition</title>
    <url>/posts/10043.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-数据集处理"><a href="#1-数据集处理" class="headerlink" title="1 数据集处理"></a>1 数据集处理</h1><p>服务器地址：10.1.16.116</p>
<p>数据集目录：&#x2F;home&#x2F;data1&#x2F;sebas&#x2F;projects&#x2F;sketch-recognition&#x2F;resnet152-test&#x2F;dataset</p>
<ul>
<li><p>原图</p>
<ul>
<li><p>sketch_data&#x2F;train   原图训练集（250类别，每个类别72张）</p>
</li>
<li><p>sketch_data&#x2F;val   原图测试集（250类别，每个类别8张）</p>
</li>
</ul>
</li>
<li><p>外部轮廓</p>
<ul>
<li><p>sketch_data&#x2F;train_external   外轮廓训练集（250类别，每个类别72张）</p>
</li>
<li><p>sketch_data&#x2F;val_external   外轮廓测试集（250类别，每个类别8张）</p>
</li>
</ul>
</li>
<li><p>内部细节</p>
<ul>
<li><p>sketch_data&#x2F;train_internal   内部细节训练集（250类别，每个类别72张）</p>
</li>
<li><p>sketch_data&#x2F;val_internal   内部细节测试集（250类别，每个类别8张）</p>
</li>
</ul>
</li>
</ul>
<h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2 网络结构"></a>2 网络结构</h1><blockquote>
<p>三分支网络，以resnet152为backbone，前两个分支之间做交叉注意力机制学习，然后再和第三个分支进行特征融合。三个分支的输入分别是三个不同的数据集，每个数据集中的图像是1111x1111x1的灰度图（白色背景，黑色线条）。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optim.Adam(model.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">train_steps = <span class="built_in">len</span>(train_loader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    model.train()</span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line">    train_correct_num = <span class="number">0</span></span><br><span class="line">    train_bar = tqdm(<span class="built_in">zip</span>(train_external_loader, train_internal_loader, train_loader), file=sys.stdout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> step, (external_data, internal_data, data) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_bar):</span><br><span class="line">        external_images, external_labels = external_data</span><br><span class="line">        internal_images, internal_labels = internal_data</span><br><span class="line">        images, labels = data</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        external_images = external_images.to(device)</span><br><span class="line">        external_labels = external_labels.to(device)</span><br><span class="line">        internal_images = internal_images.to(device)</span><br><span class="line">        internal_labels = internal_labels.to(device)</span><br><span class="line">        images = images.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">        external_outputs, internal_outputs, outputs = model(external_images, internal_images, images)</span><br><span class="line"></span><br><span class="line">        _, external_predicted = torch.<span class="built_in">max</span>(external_outputs, <span class="number">1</span>)</span><br><span class="line">        train_correct_num += (external_predicted == external_labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">        _, internal_predicted = torch.<span class="built_in">max</span>(internal_outputs, <span class="number">1</span>)</span><br><span class="line">        train_correct_num += (internal_predicted == internal_labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line">        train_correct_num += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">        external_loss = criterion(external_outputs, external_labels)</span><br><span class="line">        internal_loss = criterion(internal_outputs, internal_labels)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">        total_loss = external_loss + internal_loss + loss</span><br><span class="line">        total_loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        train_loss += total_loss.item()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3 实验结果"></a>3 实验结果</h1>]]></content>
  </entry>
  <entry>
    <title>常用命令记录</title>
    <url>/posts/35783.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-压缩、解压"><a href="#1-压缩、解压" class="headerlink" title="1 压缩、解压"></a>1 压缩、解压</h1><blockquote>
<p>tar 参数含义</p>
</blockquote>
<ul>
<li>-c：建立压缩档案</li>
<li>-x：解压</li>
<li>-t：查看内容</li>
<li>-z：有 gzip 属性的</li>
<li>-j：有 bz2 属性的</li>
<li>-Z：有 compress 属性的</li>
<li>-v：显示所有过程</li>
<li>-f：使用档案名字。该参数为最后一个参数，后面只能接档案名字</li>
<li>-O：将文件解开到标准输出</li>
</ul>
<blockquote>
<p>常用压缩和解压命令</p>
</blockquote>
<p>压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录里所有 jpg 文件打包成 jpg.tar</span></span><br><span class="line">tar -cvf jpg.tar *.jpg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录里所有的 jpg 文件打包成 jpg.tar 后，使用 gzip 压缩，生成 jpg.tar.gz</span></span><br><span class="line">tar -czvf jpg.tar.gz *.jpg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录内指定文件打包为 tar.bz2 形式</span></span><br><span class="line">tar -cjvf jpg.tar.bz2 *.jpg</span><br></pre></td></tr></table></figure>



<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压 tar 包</span></span><br><span class="line">tar -xvf fileName.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压 *.tar.gz 或者 *.tgz</span></span><br><span class="line">tar -xzvf fileName.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压 tar.bz2</span></span><br><span class="line">tar -xjvf fileName.tar.bz2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压 rar</span></span><br><span class="line">unrar e fileName.rar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压 zip</span></span><br><span class="line">unzip fileName.zip</span><br></pre></td></tr></table></figure>






<p>参考：<a href="https://blog.csdn.net/imyang2007/article/details/7634470">(126条消息) linux tar 解压命令总结_Young_2717的博客-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
