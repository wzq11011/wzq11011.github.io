[{"title":"leetcode刷题记录（1）","path":"/2025/02/27/leetcode-java-1/","content":"主要使用 java 重新刷一遍代码随想录。 2025-2-18 00:00 开始 思路： 需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法 1 数组1.1 二分查找有序数组、无重复元素 class Solution public int search(int[] nums, int target) int len = nums.length; if (target nums[0] || target nums[len - 1]) return -1; int left = 0, right = len - 1; while (left = right) int mid = (left + right) / 2; if (target == nums[mid]) return mid; else if (target nums[mid]) left = mid + 1; else right = mid - 1; return -1; 1.2 移除元素在数组中移除目标元素，然后将剩余元素往前排。（原地移除） 暴力：两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。 易错：i--，后面元素都向前移了一位，最外层循环 i 应保持不变。 class Solution public int removeElement(int[] nums, int val) int len = nums.length; for (int i = 0; i len; i++) if (nums[i] == val) for (int j = i + 1; j len; j ++) nums[j - 1] = nums[j]; i--; len--; return len; 快慢指针（数组、链表、字符串等）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 注意：fast 在前面找不同于 val 的元素，然后传给 slow class Solution public int removeElement(int[] nums, int val) int len = nums.length; int slow = 0; for (int fast = 0; fast len; fast++) if (nums[fast] != val) nums[slow] = nums[fast]; slow++; return slow; 1.3 有序数组的平方 先平方，再排序 O(n + nlogn) class Solution public int[] sortedSquares(int[] nums) for (int i = 0; i nums.length; i++) nums[i] = nums[i] * nums[i]; Arrays.sort(nums); return nums; 双指针：从两头往中间收缩，比较两头元素平方的大小。取较大值填入新数组的右边界位置 class Solution public int[] sortedSquares(int[] nums) int len = nums.length; int i = 0, j = len - 1; int[] result = new int[len]; int k = len - 1; while (i = j) if (nums[i] * nums[i] = nums[j] * nums[j]) result[k] = nums[j] * nums[j]; k--; j--; else result[k] = nums[i] * nums[i]; k--; i++; return result; 1.4 长度最小的子数组 滑动窗口：for循环控制窗口右边界，while循环控制窗口左边界 时间复杂度：O(n) 易错：result初始化，最后返回值，while循环逻辑 class Solution public int minSubArrayLen(int target, int[] nums) int len = nums.length; int left = 0, sum = 0; int result = Integer.MAX_VALUE; for (int right = 0; right len; right++) sum += nums[right]; while (sum = target) result = Math.min(right - left + 1, result); sum -= nums[left++]; return result == Integer.MAX_VALUE ? 0 : result; 1.5 螺旋矩阵 II 模拟：一圈一圈的填充矩阵，从顶部的左到右，最右边的上到下，底部的右到左，最左边的下到上。 易错：边界条件的处理 class Solution public int[][] generateMatrix(int n) int[][] nums = new int[n][n]; int startX = 0, startY = 0; int count = 1, loop = 1, offset = 1; int i, j; while (loop = n / 2) i = startX; j = startY; for (; j n - offset; j++) nums[i][j] = count++; for (; i n - offset; i++) nums[i][j] = count++; for (; j startY; j--) nums[i][j] = count++; for (; i startX; i--) nums[i][j] = count++; startX++; startY++; offset++; loop++; if (n % 2 == 1) nums[startX][startY] = count; return nums; 1.6 区间和 （自选） 前缀和：重复利用计算过的子数组之和，减少计算次数 易错： import java.util.Scanner;public class Main public static void main(String[] args) Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int[] nums = new int[n]; int[] sum = new int[n]; for (int i = 0; i n; i++) nums[i] = scan.nextInt(); if (i == 0) sum[i] = nums[i]; else sum[i] = sum[i-1] + nums[i]; while (scan.hasNextInt()) int a = scan.nextInt(); int b = scan.nextInt(); int result; if (a == 0) result = sum[b]; else result = sum[b] - sum[a - 1]; System.out.println(result); scan.close(); 1.7 开发商购买土地 （自选）2 链表2.1 移除链表元素 虚拟节点 /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode removeElements(ListNode head, int val) ListNode dummy = new ListNode(); dummy.next = head; ListNode cur = dummy; while (cur.next != null) if (cur.next.val == val) cur.next = cur.next.next; else cur = cur.next; return dummy.next; 2.2 设计链表 单链表 class MyLinkedList class ListNode int val; ListNode next; ListNode() ; ListNode(int val) this.val = val; ListNode(int val, ListNode next) this.val = val; this.next = next; private int size; private ListNode head; public MyLinkedList() this.size = 0; this.head = new ListNode(0); public int get(int index) if (index 0 || index = size) return -1; ListNode cur = head; for (int i = 0; i = index; i++) cur = cur.next; // while (index = 0) // cur = cur.next; // index--; // return cur.val; public void addAtHead(int val) ListNode tmp = new ListNode(val); tmp.next = head.next; head.next = tmp; size++; // return head; public void addAtTail(int val) ListNode cur = head; while (cur.next != null) cur = cur.next; // for (int i = 0; i size; i++) cur = cur.next; ListNode newNode = new ListNode(val); cur.next = newNode; size++; public void addAtIndex(int index, int val) if (index 0 || index size) return; ListNode cur = head; ListNode newNode = new ListNode(val); for (int i = 0; i index; i++) cur = cur.next; newNode.next = cur.next; cur.next = newNode; size++; public void deleteAtIndex(int index) if (index 0 || index = size) return; ListNode cur = head; for (int i = 0; i index; i++) cur = cur.next; cur.next = cur.next.next; size--; /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */ 双链表 2.3 翻转链表 双指针 /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode reverseList(ListNode head) ListNode pre = null, tmp = null, cur = head; while (cur != null) tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; return pre; 递归 /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode reverseList(ListNode head) return reverse(null, head); private ListNode reverse(ListNode pre, ListNode cur) if (cur == null) return pre; ListNode tmp = cur.next; cur.next = pre; return reverse(cur, tmp); 2.4 两两交换链表中的节点/** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode swapPairs(ListNode head) ListNode dummy = new ListNode(0, head); ListNode cur = dummy; while (cur.next != null cur.next.next != null) ListNode node1 = cur.next; ListNode node2 = cur.next.next; cur.next = node2; node1.next = node2.next; node2.next = node1; cur = node1; return dummy.next; 递归 class Solution public ListNode swapPairs(ListNode head) if (head == null || head.next == null) return head; ListNode next = head.next; ListNode newNode = swapPairs(next.next); head.next = newNode; next.next = head; return next; 2.5 删除链表的倒数第 N 个结点 双指针法 /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode removeNthFromEnd(ListNode head, int n) ListNode dummy = new ListNode(0, head); ListNode fast = dummy, slow = dummy; for (int i = 0; i = n; i++) fast = fast.next; while (fast != null) fast = fast.next; slow = slow.next; if (slow.next != null) slow.next = slow.next.next; return dummy.next; 2.6 链表相交2.7 环形链表II3 哈希表3.1 有效的字母异位词 字典解法 class Solution public boolean isAnagram(String s, String t) int[] record = new int[26]; for (int i = 0; i s.length(); i++) record[s.charAt(i) - a]++; for (int i = 0; i t.length(); i++) record[t.charAt(i) - a]--; for (int count : record) if (count != 0) return false; return true; 3.2 两个数组的交集 HashSet class Solution public int[] intersection(int[] nums1, int[] nums2) HashSetInteger hashSet = new HashSetInteger(); HashSetInteger result = new HashSetInteger(); for (int num : nums1) hashSet.add(num); for (int num : nums2) if (hashSet.contains(num)) result.add(num); // return result.stream().mapToInt(x - x).toArray(); int[] array = new int[result.size()]; int i = 0; for (int num : result) array[i++] = num; return array; 3.3 快乐数class Solution public boolean isHappy(int n) SetInteger set = new HashSet(); while (n != 1 !set.contains(n)) set.add(n); n = getNextNumber(n); return n == 1; public int getNextNumber(int n) int res = 0; while (n 0) int tmp = n % 10; res += tmp * tmp; n = n / 10; return res; 3.4 两数之和 两层 for 循环 HashMap： key value class Solution public int[] twoSum(int[] nums, int target) // int len = nums.length; // int[] res = new int[2]; // for (int i = 0; i len; i++) // for (int j = i + 1; j len; j++) // if (nums[i] + nums[j] == target) // res[0] = i; // res[1] = j; // // // // return res; MapInteger, Integer hashMap = new HashMap(); for (int i = 0; i nums.length; i++) int tmp = target - nums[i]; if (hashMap.containsKey(tmp)) return new int[]i, hashMap.get(tmp); else hashMap.put(nums[i], i); return null; 3.5 四数相加class Solution public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) int res = 0; MapInteger, Integer map = new HashMap(); for (int i = 0; i nums1.length; i++) for (int j = 0; j nums1.length; j++) int tmp = nums1[i] + nums2[j]; map.put(tmp, map.getOrDefault(tmp, 0) + 1); for (int i = 0; i nums3.length; i++) for (int j = 0; j nums4.length; j++) int tmp = 0 - (nums3[i] + nums4[j]); res += map.getOrDefault(tmp, 0); return res; 3.6 赎金信class Solution public boolean canConstruct(String ransomNote, String magazine) if (ransomNote.length() magazine.length()) return false; int[] count = new int[26]; for (char c : magazine.toCharArray()) count[c - a]++; for (char c : ransomNote.toCharArray()) count[c - a]--; for (int i : count) if (i 0) return false; return true; 3.7 三数之和 双指针法 3.8 四数之和4 字符串4.1 反转字符串 双指针 class Solution public void reverseString(char[] s) int len = s.length; int l = 0, r = len - 1; while (l r) char tmp = s[l]; s[l] = s[r]; s[r] = tmp; l++; r--; 4.2 反转字符串IIStringBuffer 是 Java 中的一个类，用于表示可变的字符序列。与 String 类不同，StringBuffer 的内容可以被修改而不创建新的对象，这使得它在需要频繁修改字符串内容的场景中非常有用。 4.3 替换数字import java.util.Scanner;public class Main public static String replaceNumbers(String s) int sLen = s.length(); int count = 0; for (int i = 0; i sLen; i++) if (Character.isDigit(s.charAt(i))) count++; int newSLen = sLen + count * 5; char[] newS = new char[newSLen]; int j = newSLen - 1; for (int i = sLen - 1; i = 0; i--) if (Character.isDigit(s.charAt(i))) newS[j--] = r; newS[j--] = e; newS[j--] = b; newS[j--] = m; newS[j--] = u; newS[j--] = n; else newS[j--] = s.charAt(i); return new String(newS); public static void main(String[] args) Scanner scan = new Scanner(System.in); String s = scan.next(); System.out.println(replaceNumbers(s)); scan.close(); 4.4 反转字符串里的单词4.5 右旋转字符串4.6 实现 strStr4.7 重复的子字符串5 双指针法6 栈与队列7 二叉树8 回溯算法9 贪心算法10 动态规划11 单调栈12 图论参考 代码随想录 通义千问","tags":["leetcode java"],"categories":["leetcode"]},{"title":"Java常用知识","path":"/2025/02/26/Java常用知识/","content":"基础charchar是Java的基本数据类型之一，用来表示单个字符。每个char变量占用16位（2字节），可以存储一个Unicode字符 创建 charchar ch1 = A; // 单引号内必须是单个字符char ch2 = 65; // 使用ASCII值也可以创建字符，这里会显示A 常用操作 算术运算：由于char实际上是一个整数类型的别名，所以可以直接参与算术运算。 char a = a;char b = (char)(a + 1); // 结果为b 比较：可以使用==, , , =, =等进行比较。 boolean isGreater = (d b); // true 与 String 的联系和区别 相互转换：可以通过多种方式进行char和String之间的转换 将String转换为char数组 String str = hello;char[] chars = str.toCharArray(); // 返回包含所有字符的数组 将char转换为String char ch = a;String strFromChar = Character.toString(ch); // 或者String.valueOf(ch) 区别 基本 vs 引用类型：char是基本数据类型，而String是一个引用类型。 不变性：String对象是不可变的，而char是可变的。 内存管理：String对象通常存储在堆上，而char直接存储其值。 Character概念在Java中，Character类是位于java.lang包中的一个包装类（wrapper class），它提供了对基本数据类型char的封装，并提供了一系列静态方法来操作字符。Character类的对象包含一个类型为char的单个字段，使得基本数据类型能够作为对象进行处理。 String概念在Java中，String是不可变的类，这意味着一旦创建了一个String对象，它的值就不能改变。所有对字符串的操作都会返回一个新的String对象。 （引用类型） 常用方法 length()：获取字符串长度 charAt(int index)：获取指定位置的字符 substring(int beginIndex, int endIndex)：获取子串 equals(Object anObject)：比较两个字符串是否相等 toLowerCase() 和 toUpperCase()：转换大小写 trim()：去除首尾空白字符 replace(char oldChar, char newChar)：替换字符 split(String regex)：根据正则表达式分割字符串 concat(String str)：连接字符串 indexOf(int ch) 和 lastIndexOf(int ch) 查找字符或子串的位置 不可变性由于String对象是不可变的，在进行修改操作时会生成新的String对象。 参考 通义千问","tags":["java"],"categories":["java"]},{"title":"Hello World","path":"/2025/02/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment Stellarstellar: stellar O1 2024年的小目标：完成 Volantis 6.0 并发布上线 来自2025年的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 风险 0%"},{"title":"hot 100","path":"/2024/04/17/hot 100/","content":"Leetcode hot 100 刷题记录 1 哈希基础知识： unordered_map：基于哈希表（Hash Table）实现，用于存储键值对。通过哈希函数将键转化为哈希码，然后使用哈希码作为索引快速定位到桶（bucket），每个桶内可能包含多个元素（当发生哈希冲突时） 对于查找、插入和删除操作，在理想情况下，时间复杂度为O(1)。 insert({key,value})：使用 pair 插入元素 emplace({key, value})：使用 emplace_back 方式构造并插入元素 erase()、clear() 删除所有元素 size()、empty() 映射为空则返回 true、bucket_count() 返回桶数量 begin()、end()、bucket() （返回键所在的桶编号） unordered_set：一种关联容器，类似于 set ，无序，基于哈希表实现。容器中每一个元素都是唯一的，可以高效地插入、删除、查找。 插入元素：insert() 查找元素 if (mySet.find(42) != mySet.end()) // 元素存在if (mySet.count(banana) 0) // banana 存在于集合中 删除元素：erase() 遍历元素 for (const auto item : mySet) // 遍历并处理每个元素 std::count item std::endl; emplace()：在容器内直接构造元素。 empty()：检查容器是否为空。 size()：获取容器中元素的数量。 clear()：清空所有元素。 （emplace主要用在序列容器汇总，emplace_back主要用在序列容器中） emplace_back：是 C++ 标准库中某些容器类（如 vector、deque、list等序列容器，以及 unordered_map、map等关联容器）提供的成员函数，该方法允许在容器的末尾直接构造新的元素，而不用先创建好元素再插入。避免了额外拷贝或移动构造函数的调用，相比较于先创建临时变量再用 push_back 添加的方式，这种方法更高效，省去了临时对象的创建和销毁过程。 1.1 字母异位词题目链接：49. 字母异位词分组 - 力扣（LeetCode） 思路： 判断两个字符串是否相等，可以对字符串中的字母做排序，然后比较二者是否相等。 使用哈希表存储每一组字母异位词，键为字母异位词标志（排序后的字符串），值为字母异位词。 方法一：字母排序 时间复杂度：O(NKlogK) 遍历单词：O(N) 排序字符：O(KlogK) 空间复杂度：O(NK) n 是 strs 中字符串的数量，k 是 strs 中字符串的最大长度。需要使用哈希表存储全部字符串。 class Solution public: vectorvectorstring groupAnagrams(vectorstring strs) unordered_mapstring, vectorstring map; for (string str : strs) string key = str; sort(key.begin(), key.end()); map[key].emplace_back(str); vectorvectorstring result; for (auto it = map.begin(); it != map.end(); it++) result.emplace_back(it-second); return result; ; 方法二：字符计数 （代码未理解） 互为字母异位词的两个字符串包含的字母相同，相同字母出现的次数也相同，可以将每个字母出现的次数使用字符串表示，作为哈希表的键。 class Solution public: vectorvectorstring groupAnagrams(vectorstring strs) // 自定义对 arrayint, 26 类型的哈希函数 auto arrayHash = [fn = hashint] (const arrayint, 26 arr) - size_t return accumulate(arr.begin(), arr.end(), 0u, [](size_t acc, int num) return (acc 1) ^ fn(num); ); ; unordered_maparrayint, 26, vectorstring, decltype(arrayHash) mp(0, arrayHash); for (string str: strs) arrayint, 26 counts; int length = str.length(); for (int i = 0; i length; ++i) counts[str[i] - a] ++; mp[counts].emplace_back(str); vectorvectorstring ans; for (auto it = mp.begin(); it != mp.end(); ++it) ans.emplace_back(it-second); return ans; ; 1.2 最长连续序列 题目链接：128. 最长连续序列 - 力扣（LeetCode） 思路：枚举数组中每一个数 x ，以此数为起点找连续序列（即不断寻找 x+1 、x+2 、x+3 … x+y ），假设最长匹配到了 x+y ，则以 x 为起点的最长序列长度为 y+1 。 优化： 1、使用 set 对数组去重，避免重复的起点。 2、如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，则以 x+1，x+2,...,x+y 中的数为起点造成重复。以要枚举的起点为 x 为例，在哈希表中检查是否存在 x-1 来判断是否跳过该起点。 class Solution public: int longestConsecutive(vectorint nums) int result = 0; unordered_setint num_set; for (const int num : nums) num_set.insert(num); for (const int num : num_set) if (num_set.find(num-1) == num_set.end()) int currentNum = num; int currentLength = 1; while (num_set.find(currentNum + 1) != num_set.end()) currentNum++; currentLength++; result = max(result, currentLength); return result; ; 2 双指针2.1 移动零 题目链接：283. 移动零 - 力扣（LeetCode） 思路：左指针找零，右指针找非零数，然后交换并右移，直到数组最后一个数。 class Solution public: void moveZeroes(vectorint nums) int left = 0; int right = 0; while (right nums.size()) if (nums[right] != 0) if (nums[left] == 0) swap(nums[left], nums[right]); left++; right++; ; 时间复杂度：O(n) 空间复杂度：O(1) 2.2 盛最多水的容器 题目链接：11. 盛最多水的容器 - 力扣（LeetCode） 思路：以双指针为数组的左右边界，固定一个指针，移动另一个指针，不断地计算面积从而得到容量的最大值。 优化： 1、如果左指针高度比右指针低，则固定右指针，移动左指针，反之亦然。（我们期望较小的一边在移动过程中变大，从而增加盛水容量） 2、如果移动后高度小于等于原高度，则面积必然减小，省略计算面积的步骤。（简化计算） class Solution public: int maxArea(vectorint height) int left = 0, right = height.size() - 1; int result = 0; while (left right) result = max(result, min(height[left], height[right]) * (right - left)); if (height[left] = height[right]) left++; else right--; return result; ; 2.3 三数之和 题目链接：15. 三数之和 - 力扣（LeetCode） 思路：for 循环里面包着左右指针。i 的下标从 0 开始，定义 left 在 i+1 位置上， right 在数组末尾上。判断 nums[i]+nums[left]+nums[right] 的值，大于 0 右指针左移，小于 0 左指针右移。 优化： 1、如果排序后第一个元素大于0，则三数合必大于0； 2、对 i 去重，如果当前的 nums[i] 与前一个相等，则跳过 3、对 left right 去重，类似第 2 步。 class Solution public: vectorvectorint threeSum(vectorint nums) // for 循环里面包着左右指针 vectorvectorint result; sort(nums.begin(), nums.end()); for (int i = 0; i nums.size(); i++) if (nums[i] 0) return result; // 对 i 去重 if (i 0 nums[i] == nums[i-1]) continue; int left = i + 1, right = nums.size() - 1; while (left right) if (nums[i] + nums[left] + nums[right] 0) right--; while (left right nums[right] == nums[right-1]) right--; else if (nums[i] + nums[left] + nums[right] 0) left++; while (left right nums[left] == nums[left+1]) left++; else result.push_back(nums[i], nums[left], nums[right]); // 找到一组三元组后，对 left 和 right 去重 left++; right--; return result; ; 2.4 接雨水 题目链接：42. 接雨水 - 力扣（LeetCode） 思路： 对于下标为 i 的格子，其能接的最大雨水量为两边最大高度的较小值，减去i 处的高度 height[i] 。 对每个下标 i 向两边扫描得到最大高度，时间复杂度为 O(n)；然后对每个下标求能接的雨水量，时间复杂度也为 O(n) ，总时间复杂度为 O(n^2) 。 优化： 1、使用动态规划更快地得到每个位置两边的最大高度。 创建两个长度为 n 的数组 leftMax 和 rightMax ，leftMax[i] 表示下标 i 及其左边位置中的最大高度，rightMax[i] 表示下标 i 及其右边位置中的最大高度。 class Solution public: int trap(vectorint height) int n = height.size(); if (n == 0) return 0; vectorint leftMax(n, 0); // leftMax[0] = height[0]; for (int i = 0; i n; i++) if (i == 0) leftMax[i] = height[i]; else leftMax[i] = max(leftMax[i - 1], height[i]); vectorint rightMax(n, 0); for (int i = n - 1; i = 0; i--) if (i == n - 1) rightMax[i] = height[i]; else rightMax[i] = max(rightMax[i + 1], height[i]); int ans = 0; for (int i = 0; i n; i++) ans += min(leftMax[i], rightMax[i]) - height[i]; return ans; ; 时间复杂度：O(n) ，实际对整个数组遍历了三次 空间复杂度：O(n) ，需要创建两个长度为 n 的数组 leftMax 和 rightMax 。 2、单调栈 3、双指针 动态规划中需要维护两个数组 leftMax 和 rightMax ，空间复杂度为 O(n) 3 滑动窗口 参考：我写了首诗，把滑动窗口算法变成了默写题 滑动窗口算法主要用来解决子数组问题，如寻找符合某个条件的最长最短子数组。 通过维护一个窗口，不断滑动，更新答案。算法模板如下： volid slidingWindow(string s) unordered_mapchar, int window; int left = 0, right = 0; while (right s.size()) char c = s[right]; // c 是将要移入窗口的元素 window.add(c); right++; // 判断窗口是否要收缩 while (left right window needs shrink) char d = s[left]; // d 是将要从窗口移除的元素 window.remove(d); left++; // 缩小窗口 // 对窗口内数据更新... 3.1 无重复字符的最长子串 题目链接：3. 无重复字符的最长子串 - 力扣（LeetCode） 思路：for 循环控制滑动窗口的左侧边界，右侧边界 right 逐一向右遍历元素，使用 unordered_set 判断是否有重复元素，有重复元素就把左边界向右移动，直至窗口内无重复元素，比较各个窗口，记录最大长度。 class Solution public: int lengthOfLongestSubstring(string s) int n = s.size(); int right = 0, ans = 0; unordered_setchar set; for (int i = 0; i n; i++) while (right n !set.count(s[right])) set.insert(s[right++]); set.erase(s[i]); ans = max(ans, right - i); return ans; ; 类题： 567. 字符串的排列 - 力扣（LeetCode） 3. 无重复字符的最长子串 - 力扣（LeetCode） 3.2 找到字符串中所有字母异位词 题目链接：438. 找到字符串中所有字母异位词 - 力扣（LeetCode） 思路：套用模板 class Solution public: vectorint findAnagrams(string s, string p) unordered_mapchar, int need, window; for (char c : p) need[c]++; int left = 0, right = 0; // 左闭右开 int start = 0, valid = 0; vectorint res; while (right s.size()) char c = s[right++]; if (need.count(c)) window[c]++; if (window[c] == need[c]) valid++; // 判断是否缩小窗口 while (right - left = p.size()) if (valid == need.size()) res.push_back(left); char d = s[left++]; if (need.count(d)) if (window[d] == need[d]) valid--; window[d]--; return res; ; 4 子串 前缀和 优先队列：一种抽象数据类型，类似队列，其中元素按照一定优先级顺序排列，出队顺序按照优先级从高到低（或从低到高）。 4.1 和为 K 的子数组 题目链接：560. 和为 K 的子数组 - 力扣（LeetCode） 思路： 1、暴力解法：枚举 两层 for 循环，先固定左侧 left ，然后向右移动 right ，直到窗口内元素相加和为 k ，此时计数加 1。时间复杂度 O(n^2) ，容易超时。 class Solution public: int subarraySum(vectorint nums, int k) // 暴力解法：枚举 int n = nums.size(); int res = 0; for (int left = 0; left n; left++) int sum = 0; for (int right = left; right n; right++) sum += nums[right]; if (sum == k) res++; return res; ; 2、前缀和 + 哈希表优化 思路：计算前 i 个数的和，存储到数组中。如果前 i 个数的和与前 j 个数之和的差为 k （0=ji)，则 i 与 j 之间的子数组满足要求 class Solution public: int subarraySum(vectorint nums, int k) unordered_mapint, int map; map[0] = 1; int sum = 0, res = 0; for (const int x : nums) sum += x; if (map.find(sum - k) != map.end()) res += map[sum - k]; map[sum]++; return res; ; 4.2 滑动窗口最大值 题目链接：239. 滑动窗口最大值 - 力扣（LeetCode） 思路：对于每个滑动窗口，可以使用 O(k) 的时间复杂度遍历其中每个元素，找出其中最大值。对于长度为 n 的数组，窗口数量为 n-k+1 ，总时间复杂度为 O(n*(n-k+1))=O(n*(n-k)) 。 1、优先队列：初始时，将数组 nums 的前 k 个元素放入优先队列中，每次向右移动窗口时，将一个新元素放入优先队列中，此时堆顶元素为堆中最大值。此最大值可能在新窗口中，也可能在上一窗口的最左侧（此时需要删除该最大值，重新计算堆中最大值作为新窗口的最大值）。 class Solution public: vectorint maxSlidingWindow(vectorint nums, int k) // 优先队列 prioriry_queue int n = nums.size(); priority_queuepairint, int q; vectorint res; for (int i = 0; i k; i++) q.emplace(nums[i], i); res.push_back(q.top().first); for (int i = k; i n; i++) q.emplace(nums[i], i); while (q.top().second = i - k) q.pop(); res.push_back(q.top().first); return res; ; 2、单调队列 4.3 最小覆盖子串 题目链接：76. 最小覆盖子串 - 力扣（LeetCode） 思路： 1、在字符串 S(source) 中使用双指针寻找符合条件的 T (target) ，初始化 left=right=0 ，把左闭右开的 [left,right) 当做窗口。 2、right 不断地右移直至窗口中元素都包含 T 中所有字符 3、然后 left 左移缩小窗口，直到窗口内字符串不再符合要求 4、重复2、3步，直到 right 到达字符串 S 的末尾。 class Solution public: string minWindow(string s, string t) // need：记录所需的字符 // window：记录窗口内包含的字符 unordered_mapchar, int need, window; // 对于哈希表，使用方括号访问键对应的值 map[key]，但当 key 不存在时， // C++会自动创建该 key，并把 map[key] 赋值为 0。 for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; // 记录 window 内符合要求的字符数 int start = 0, len = INT_MAX; // 记录最小覆盖子串起始索引及长度 while (right s.size()) // right 右移，扩大滑窗，直至窗口内元素满足要求 char c = s[right++]; if (need.count(c)) window[c]++; if (window[c] == need[c]) valid++; // 判断是否要缩小窗口 while (valid == need.size()) // 记录最小子串长度，如果当前子串长度小于之前的最小子串长度 if (right - left len) start = left; len = right - left; // 如果最左侧要移除的元素是 need 中所需元素，导致 valid - 1，进而跳出 while 循环。 char d = s[left++]; // 将要移除的元素 if (need.count(d)) if (window[d] == need[d]) valid--; window[d]--; return len == INT_MAX ? : s.substr(start, len); ; 5 普通数组5.1 最大子数组和 题目链接：53. 最大子数组和 - 力扣（LeetCode） 思路： 1、动态规划：假设 nums 数组长度为 n ，下标从 0 到 n-1 。使用 f(i) 表示以第 i 个数结尾的数组中最大的子数组和。只需求出每个 f(i) ，然后取最大值即可。考虑 nums[i] 单独成为一段或者加入 f(i-1) 对应的那一段，动态转移方程为 f(i) = max f(i-1)+nums[i], nums[i] 。（注意：不管取那一段都是以 nums[i] 结尾的） class Solution public: int maxSubArray(vectorint nums) int dp = 0, res = INT_MIN; for (int i = 0; i nums.size(); i++) if (i == 0) dp = nums[i]; else dp = max(dp + nums[i], nums[i]); res = max(res, dp); return res; ; 时间复杂度：O(n) 空间复杂度：O(1) 2、分治 5.2 合并区间 题目链接：56. 合并区间 - 力扣（LeetCode） 思路：将列表中的区间按照左端点升序排序，将第一个区间加入 res 数组，然后依次考虑后面的区间。如果当前区间左端点大于 res 数组中最后一个区间的右端点，则不合并（即添加到 res 数组中）。若小于等于，则两个区间重合，使用当前区间的右端点更新数组中最后一个区间的右端点。 class Solution public: vectorvectorint merge(vectorvectorint intervals) vectorvectorint res; sort(intervals.begin(), intervals.end()); for (auto interval : intervals) if (res.empty() || res.back()[1] interval[0]) res.push_back(interval); else res.back()[1] = max(res.back()[1], interval[1]); return res; ; 5.3 轮转数组 题目链接：189. 轮转数组 - 力扣（LeetCode） 思路： 1、使用额外的数组：n 表示数组长度，遍历原数组，将原数组下标为 i 的元素放到新数组下标为 (i+k)mod n 的位置，然后将新数组拷贝到原数组。 class Solution public: void rotate(vectorint nums, int k) int n = nums.size(); vectorint res(n); for (int i = 0; i n; i++) res[(i + k) % n] = nums[i]; nums.assign(res.begin(), res.end()); // 拷贝数组 ; 2、 5.4 除自身以外数组的乘积 题目链接：238. 除自身以外数组的乘积 - 力扣（LeetCode） 思路： 1、左右乘积列表：分解问题，对于给定索引i ，将左边数字乘积和右边数字乘积相乘得到答案。初始化两个空数组L 和 R ，因为第一个元素左边没有元素，所以 L[0] 初始化为 1，L[i] = L[i-1] * nums[i] 。R 同理，索引 i 处的值为：L[i] * R[i] 。 5.5 缺失的第一个正数","tags":["leetcode"],"categories":["leetcode"]},{"title":"leetcode","path":"/2023/07/13/leetcode/","content":"代码随想录地址：https://programmercarl.com/ 以下学习内容来自于 chatgpt、通义千问等大语言模型（LLMs） 菜鸟教程 - 学的不仅是技术，更是梦想！ 代码随想录： 第一遍完成时间：2024-3-1 ~ 1 c++引用指针 定义：在C++中，指针提供了直接访问内存地址的能力，允许对内存进行灵活的操作。 1、定义指针：指针是一个变量，其存储的值是另一个变量的内存地址。可使用以下语法定义指针： int* ptr; // 定义一个指向整数的指针 此处的 * 表示指针，int* 表示指向整数的指针。 2、获取地址：可以使用取地址运算符 来获取变量的内存地址，并将其赋值给指针： int var = 10;int* ptr = var; // ptr 指向变量 var 的地址 3、解引用：可以使用解引用运算符 * 来访问指针所指向的内存地址存储的值： int var = 10;int* ptr = var;int value = *ptr; // value 的值为10，即 ptr 所指向的内存地址处的值 4、空指针：指针可以指向空地址，表示不指向任何有效的内存位置，可以使用特殊的空指针常量 nullptr 来表示空指针 int* ptr = nullptr; // 定义一个空指针 5、动态内存分配：可以使用 new 运算符来在堆上动态分配内存，返回分配内存的地址，并将其赋值给指针。需要记得不再使用内存时，使用 delete 运算符释放内存，防止内存泄露。 int* ptr = new int; // 在堆上动态分配一个整数的内存，并将其地址赋值给指针*ptr = 10; // 向分配的内存中存储值delete ptr; // 释放分配的内存 6、数组指针：指针也可以指向数组的首地址，这样就可以通过指针来访问数组的元素 int arr[5] = 1, 2, 3, 4, 5;int* ptr = arr; // 将数组的首地址赋值给指针 指针数组：让数组存储指向 int 或 char 或其他数据类型的指针 #include iostreamusing namespace std;const int MAX = 4;int main() const char *names[MAX] = Zara Ali, Hina Ali, Nuha Ali, Sara Ali; for (int i = 0; i MAX; i++ ) cout Value of names[ i ] = ; cout names[i] endl; return 0;// 输出结果如下：Value of names[0] = Zara AliValue of names[1] = Hina AliValue of names[2] = Nuha AliValue of names[3] = Sara Ali names是一个数组，数组中每个元素都是一个指向 const char 类型的指针。在将字符串常量作为初始值赋值给 names 数组时，实际上是将这些字符串常量的首地址赋给了 names数组中的指针元素。所以在循环中打印 names[i] 时会输出字符串内容而不是地址。 7、指针的算术运算：加法、减法等，但要注意指针的类型 int arr[5] = 1, 2, 3, 4, 5;int* ptr = arr;ptr++; // 指向数组的下一个元素 我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。下面的程序递增变量指针，一遍顺序访问数组中的每一个元素： #include iostreamusing namespace std;const int MAX = 3;int main() int var[MAX] = 10, 100, 200; int *ptr; // 指针中的数组地址 ptr = var; for (int i = 0; i MAX; i++) cout Adress of var[ i ] = ; cout ptr endl; cout Value of var[ i ] = ; cout *ptr endl; // 将指针移动到下一个位置 ptr++; return 0; 以上代码的输出结果为： Address of var[0] = 0xbfa088b0Value of var[0] = 10Address of var[1] = 0xbfa088b4Value of var[1] = 100Address of var[2] = 0xbfa088b8Value of var[2] = 200 指针的比较：指针可以用关系运算符进行比较，如 、 和 。如果 p1 和 p2 指向两个相关的变量，例如同一个数组中的不同元素，则可以对 p1 和 p2 进行比较。 以上程序的另一种写法：只要变量指针所指向的地址小于等于数组最后一个元素的地址 var[MAX-1] ，就把变量指针进行递增： #include iostreamusing namespace std;const int MAX = 3;int main() int var[MAX] = 10, 100, 200; int *ptr; ptr = var; // 将数组中第一个元素的地址赋给指针 int i = 0; while (ptr = var[MAX - 1]) cout Adress of var[ i ] = ; cout ptr endl; cout Value of var[ i ] = ; cout *ptr endl; // 将指针移动到下一个位置 ptr++; i++ return 0; 8、指针和函数：指针可以作为函数的参数，用于传递地址，实现对函数外部变量的修改。也可以作为函数的返回值，返回指向堆上分配内存的地址。 C++ 允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。 下面的实例中，我们传递一个无符号（C++中用于描述整数类型的关键字，表示该类型的取值范围为非负整数，包括0，不包括负整数）的 long 型指针给函数，并在函数内改变这个值： #include iostream#include ctimeusing namespace std;// 写函数时应习惯性的先声明函数，再定义函数void getSeconds (unsigned long *par)int main() unsigned long sec; getSeconds (sec); // 输出实际值 cout Number of seconds: sec endl; return 0;void getSeconds (unsigned long *ptr) // 获取当前秒数 *ptr = time(NULL); return; 9、指向指针的指针：指向指针的指针是一种多级间接寻址形式，或者说是一个指针链。指针的指针就是将一个指针的地址存放到另一个指针里面。 通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。 一个指向指针的指针变量必须进行如下声明， 即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针： int **var; 当一个目标值被一个指针间接指向另一个指针时，访问这个值需要使用两个星号运算符，如下所示： #include iostreamusing namespace std;int main() int var; int *ptr; int **pptr; var = 3000; // 获取 var 的地址 ptr = var; // 使用运算符 获取 ptr 的地址 pptr = ptr; // 使用 pptr 获取值 cout the value of var: var endl; cout the value of *ptr: *ptr endl; cout the value of **pptr: **pptr endl; return 0; 总结：指针是C++中一个非常重要和强大的特性，它可以用于动态内存管理、数组访问、函数调用等方面，但需要谨慎使用，避免出现内存泄露和悬挂指针等问题。 模板 定义：c++中的模板（Template）是一种通用编程技术，它允许程序员编写通用的代码，使其可以适用于不同的数据类型。模板可以用于函数、类、结构体等，通过模板可以实现泛型编程。 以下是c++模板中的几种常见用法： 1、函数模板：允许定义通用的函数，可以用于处理不同类型的数据，定义函数模板的语法如下： // 函数模板声明template typename TT add (T a, T b) return a+b; 这个函数模板 add 可以对两个相同类型的数据进行加法运算，无论该类型是整数、浮点数、字符串还是其他类型。 2、类模板：类模板允许定义通用的类，可用于创建不同类型的对象，定义语法如下： template typename Tclass Pair private: T first 泛型 在编写代码时，经常会遇到相同的逻辑需要用于不同的数据类型，此时没有必要为每种数据类型编写单独的代码。泛型就是为了解决这个问题而提出的一种编程范式。 c++中，泛型编程通过模板（Template）实现，模板允许程序员编写通用的代码，使得它可以适用于不同的数据类型。 举例：假设我们有一个函数用于交换两个整数的值： void swapIntegers(int a, int b) int temp = a; a = b; b = temp; 如果我们需要交换两个浮点数或字符串，就需要重新编写一个交换函数，这样就会导致代码冗余和维护困难。 而使用泛型，可以定义一个通用的交换函数模板，如下： template typename Tvoid swapIntegers(T a, T b) T temp = a; a = b; b = a; 该模板中，typename T 表示我们将使用一个泛型类型 T，这个模板函数可以接受任意类型的参数 a 和 b，并交换它们的值。调用该函数时，编译器会根据传入参数的类型实例化模板，生成对应的函数版本。 STLSTL（Standard Template Lubrary）是 C++ 标准库中的一个重要组成部分，提供了丰富的容器、算法和函数对象等工具，使得 C++ 变成更加高效和便捷。 容器vector 是一种动态数组，提供了快速的随机访问和动态调整大小的能力 #include iostream#include vectorusing namespace std;int main() // 创建一个向量存储 int 类型数据 vectorint vec; int i; // 显示 vec 的原始大小 cout vector size = vec.size() endl; // 推入 5 个值到向量中 for (int i = 0; i 5; i++) vec.push_back(i); // 使用迭代器 iterator 范文值 vectorint::iterator v = vec.begin(); while (v != vec.end()) cout value of v = *v endl; v++; return 0; push_back() 成员函数在向量的末尾插入值，如果有必要则拓展向量的大小 size() 函数显示向量的大小 begin() 函数返回一个指向向量开头的迭代器 end() 函数返回一个指向向量末尾的迭代器 empty() 函数检查向量是否为空 front() 函数获取向量的第一个元素 back() 函数获取向量的最后一个元素 data() 函数返回指向向量数据的指针 at() 函数获取对应位置的元素 算法迭代器2 Leetcode2.1 数组27.移除元素力扣题目链接(opens new window) 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums [3,2,2,3], val 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums [0,1,2,2,3,0,4,2], val 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 你不需要考虑数组中超出新长度后面的元素。 思路：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。 方法一：暴力求解两层for 循环，一个循环遍历数组元素，第二个循环更新数组 class Solution public: int removeElement(vectorint nums, int val) int size = nums.size(); for (int i = 0; i size; i++) if (nums[i] == val) for (int j = i + 1; j size; j++) nums[j - 1] = nums[j]; // 因为每次进 for 都要对 i 加 1，前面删除了一个元素， // 此处 i-1 要保持下一次进入循环后还是原来的 i。 i--; size--; return size; ; 时间复杂度：O(n^2) 空间复杂度：O(1) 方法二：双指针法（快慢指针）通过一个快指针和慢指针在一个 for 循环中完成两个 for 循环的工作 定义快慢指针 快指针：寻找新数组的元素，新数组就是不含目标元素的数组 慢指针：指向更新后的新数组下标的位置 删除过程： 暂时无法在飞书文档外展示此内容 双指针法（快慢指针法）在数组、链表、字符串等操作中很常见 class Solution public: int removeElement(vectorint nums, int val) int slowIndex = 0; for (int fastIndex = 0; fastIndex nums.size(); fastIndex++) if (val != nums[fastIndex]) // 未找到目标值元素时，两个指针都往后走一步 // 找目标值元素时，慢指针不动，快指针继续往下走 nums[slowIndex++] = nums[fastIndex]; return slowIndex; ; 时间复杂度：O(n) 空间复杂度：O(1) 相关题目推荐： 26.删除排序数组中的重复项(opens new window) 283.移动零(opens new window) 844.比较含退格的字符串(opens new window) 977.有序数组的平方(opens new window) Java 版本 class Solution public int removeElement(int[] nums, int val) // 快慢指针 int slowIndex = 0; for (int fastIndex = 0; fastIndex nums.length; fastIndex++) if (nums[fastIndex] != val) nums[slowIndex] = nums[fastIndex]; slowIndex++; return slowIndex; 997.有序数组的平方力扣题目链接 代码随想录 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums [-7,-3,2,3,11] 输出：[4,9,9,49,121] 方法一：暴力求解每个数平方之后，再排序 class Solution public: vectorint sortedSquares(vectorint A) for(int i = 0; i A.size(); i++) A[i] *= A[i]; // 遍历每个数，然后平方 sort(A.begin(), A.end()); // 快速排序 return A; ; 该方法的时间复杂度为 O(n + nlogn)，可以近似为 O(nlogn) 的时间复杂度。 方法二：双指针法双指针法通常用于处理数组或链表等数据结构，这种技巧通常使用两个指针来解决问题，分别称为快指针和慢指针，它们分别在数据结构上以不同的速度移动，以达到解决问题的目的。 双指针法通常用于解决以下问题： 1、数组、链表中的搜索或遍历 2、数组、链表中的查找和匹配 3、数组、链表中的区间问题 双指针法分为两种类型：快慢指针、左右指针 本题使用左右指针，比较左右两侧数值的大小，取较大值存入新数组的最右边（以形成从小到大的排列规律） 暂时无法在飞书文档外展示此内容 class Solution public: vectorint sortedSquares(vectorint nums) int k = nums.size() - 1; vectorint result(nums.size(), 0); // for (int i = 0; int j = nums.size() - 1; i = j) 没有加分号 for (int i = 0, j = nums.size() - 1; i = j;) if (nums[i] * nums[i] nums[j] * nums[j]) result[k--] = nums[j] * nums[j]; j--; else result[k--] = nums[i] * nums[i]; i++; return result; ; 时间复杂度：O(n) Java 版本代码 class Solution public int[] sortedSquares(int[] nums) int right = nums.length - 1; int left = 0; int[] result = new int[nums.length]; int index = result.length - 1; while (left = right) if (nums[left] * nums[left] nums[right] * nums[right]) result[index--] = nums[right] * nums[right]; right--; else result[index--] = nums[left] * nums[left]; left++; return result; 209.长度最小的子数组力扣题目链接 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s 7, nums [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示： 1 target 10^9 1 nums.length 10^5 1 nums[i] 10^5 方法一：暴力解法两个 for 循环不断地寻找符合条件的子序列，时间复杂度为 O(n^2) 。 class Solution public: int minSubArrayLen(int s, vectorint nums) int result = INT32_MAX; // 储存最终的结果（最小子序列长度） int sum = 0; // 子序列之和 int subLength = 0; // 子序列长度 for(int i = 0; i nums.size(); i++) sum = 0; for(int j = i; j nums.size(); j++) sum += nums[j]; // 求和 if(sum = s) subLength = j - i + 1; // 计算子序列的长度 result = result subLength ? result : subLength; break; // 找到符合条件最短子序列，结束循环 // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; 时间复杂度：O(n^2) 空间复杂度：O(1) 方法二：滑动窗口通过不断调整子序列的起始位置和终止位置，得到想要的结果 这里还是以题目中的示例来举例，s7， 数组是 2，3，1，2，4，3，来看一下查找的过程： 暂时无法在飞书文档外展示此内容 class Solution public: int minSubArrayLen (int s, vectorint nums) int result = INT32_MAX; // 保存最终的结果 int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口的起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j nums.size(); j++) sum += nums[j]; // 计算第一个元素到最后一个元素 j 的序列之和 // 如果该序列和大于s，则缩减 while (sum = s) subLength = j - i + 1; // 计算子序列长度 result = result subLength ? result : subLength; // 将长度存入 result sum -= nums[i--]; // 缩减长度，同时动态调整子序列的初始位置 return result == INT32_MAX ? 0 : result; 时间复杂度：O(n) 空间复杂度：O(1) 一些录友会疑惑为什么时间复杂度是O(n)。 不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。 相关题目推荐 904.水果成篮(opens new window) 76.最小覆盖子串(opens new window) Java 语言版本 class Solution // 滑动窗口 public int minSubArrayLen (int s, int[] nums) int left = 0; int sum = 0; int result = Integer.MAX_VALUE; for (int right = 0; right nums.length; right++) sum += nums[right]; while (sum = s) result = Math.min(result, right - left + 1); sum -= nums[left++]; return result == Integer.MAX_VALUE ? 0 : result; 59.螺旋矩阵II力扣题目链接(opens new window) 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 面试频率较高，模拟过程，十分考察对代码的掌控能力。 模拟顺时针画矩阵的过程: 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 由外向内一圈一圈这么画下去。 可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是一进循环深似海，从此offer是路人。 这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。 这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。这也是坚持了每条边左闭右开的原则。 class Solution public: vectorvectorint generateMatrix (int n) // 使用 vector 定义一个二维数组 vectorvectorint res(n, vectorint(n, 0)); int startx = 0, starty = 0; // 定义每循环一个圈的起始位置 // 每个圈循环几次，例如n为奇数3，则loop=1，只循环一圈，矩阵中间的值需要单独处理 int loop = n/2; int mid = n/2; // 矩阵中间的位置，例如n为3，则中间位置为（1,1），n为5，中间位置为（2,2） int count = 1; // 用来给矩阵中每一个空格赋值 int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位 int i,j; while (loop--) i = startx; j = starty; // 以下的四个for循环模拟转圈的过程 // 模拟填充最上面一行，从左到右（左闭右开） for (j = starty; j n - offset; j++) res[startx][j] = count++; // 模拟填充最右边一列，从上到下（左闭右开） for (i = startx; i n - offset; i++) res[i][j] = count++; // 模拟填充最下面一行，从右到左（左闭右开） for (; j starty; j--) res[i][j] = count++; // 模拟填充最左边一列，从下到上（左闭右开） for (; i startx; i--) res[i][j] = count++ // 第二圈开始的时候，起始位置要+1 // 例如：第一圈起始位置为（0,0），第二圈起始位置为（1,1） startx++; starty++; // offset 控制每一圈每一条边遍历的长度 offset++; // 如果 n 为奇数的话，需要单独给矩阵最中间的位置赋值 if (n % 2) res[mid][mid] = count; return res; ; 时间复杂度：O(n^2) 空间复杂度：O(1) 类题： 54.螺旋矩阵(opens new window) 剑指Offer 29.顺时针打印矩阵(opens new window) 2.2 链表概念链表是一种通过指针串联在一起的线性结构，每个节点由两部分组成，一个数据域（存放数据）一个指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null （空指针）。 链表的入口节点（头结点）为 head。 双链表：每个节点有两个指针域，一个指向下一节点，一个指向上一节点。双链表既可向前查询又可向后查询。 循环链表：首尾相连的链表，可以用来解决约瑟夫环问题。 链表的存储方式：数组在内存中是连续分布的，链表在内存中可以不是连续分布的。链表通过指针域的指针链接在内存中各个节点，各个节点散乱分布在内存的某个地址上，分配机制取决于操作系统的内存管理。 该链表起始节点为2，终止节点为7，各个节点分布在内存的不同地址空间上，通过指针串联在一起。 链表节点定义// 单链表struct ListNode int val; // 节点上存储的元素 ListNode *next; // 指向下一节点的指针 ListNode(int x) : val(x), next(NULL) // 节点的构造函数 ; 如果在链表节点的定义中不定义构造函数，C++会默认生成一个构造函数，但该构造函数不会初始化任何成员变量，例如： 通过自己定义的构造函数初始化节点： ListNode* head = new ListNode(5); 使用默认构造函数初始化节点（注意：初始化时不能直接给变量赋值）： ListNode* head = new ListNode();head-val = 5; 链表操作删除节点要删除 D 节点，只需要将 C 节点的 next 指针指向 E 节点就可以了。然后再手动的释放 D 节点 （释放内存），其他语言如 Java、Python 有自己的内存回收机制，不用手动释放内存。 添加节点添加节点类似，只需要改动指针指向即可。链表的增添和删除都是 O(1) 操作，不会影响其他节点。 但需注意：如果要删除最后一个节点，需要从头结点查找到倒数第二个节点，然后通过 next 指针进行删除操作，查找的时间复杂度是 O(n)。 性能分析数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。 链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。 203.移除链表元素力扣题目链接(opens new window) 题意：删除链表中等于给定值 val 的所有节点。 示例 1： 输入：head [1,2,6,3,4,5,6], val 6 输出：[1,2,3,4,5] 示例 2： 输入：head [], val 1 输出：[] 示例 3： 输入：head [7,7,7,7], val 7 输出：[] 对于单链表，如果删除头结点如何处理？ 两种操作方式： 直接使用原来的链表进行删除操作 class Solution public: ListNode* removeElements (ListNode* head, int val) // 当链表存在且头结点的值是目标值时，删除头结点 while (head != NULL head-val == val) ListNode* tmp = head; head = head-next; delete tmp; // 删除非头结点 ListNode* cur = head; while (cur != NULL cur-next != NULL) if (cur-next-val == val) ListNode* tmp = cur-next; cur-next = tmp-next; // cur-next-next delete tmp; else cur = cur-next; return head; ; 时间复杂度：O(n) 空间复杂度：O(1) 设置一个虚拟头结点进行删除操作 class Solution public: ListNode* removeElements (ListNode* head, int val) ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-next = head; // 将虚拟头结点指向head，方便后面的删除操作 ListNode* cur = dummyHead; while (cur-next != NULL) if (cur-next-val == val) ListNode* tmp = cur-next; cur-next = tmp-next; delete tmp; else cur = cur-next; head = dummyHead-next; delete dummyHead; return head; ; 时间复杂度：O(n) 空间复杂度：O(1) 707 设计链表力扣题目链接(opens new window) 题意： 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 使用虚拟头结点，代码实现更方便。虚拟头结点通常用于简化链表操作，使得头结点和其他节点的操作一致化。 class MyLinkedList public: // 定义链表节点结构体 struct LinkedNode int val; LinkedNode* next; // 该构造函数的简写是 C++ 中的一种特性，称为成员初始化列表。 // 在构造函数的参数列表后面使用冒号，按照成员变量的顺序列出每个成员变量， // 后面跟着该成员变量的初始化值。 LinkedNode(int val):val(val), next(nullptr) // 构造函数 ; // 初始化链表。无参构造函数，用于初始化 MyLinkedList 类的对象 MyLinkedList() _dummyHead = new LinkedNode(0); _size = 0; // 获取第 index 个节点数值，如果 index 是非法数值直接返回 -1 int get (int index) if (index _size - 1 || index 0) return -1; LinkedNode* cur = _dummyHead-next; // 只有当判断为 0 时才会跳出 while 循环，非零情况会一直循环下去 while (index--) // --index 会陷入死循环，一开始就输入 0 cur = cur-next; return cur-val; // 在链表最前面插入一个节点，插入完成后，新插入的结点为链表的新头结点 void addAtHead (int val) LinkedNode* newNode = new LinkedNode(val); newNode-next = _dummyHead-next; _dummyHead-next = newNode; _size++; // 在链表最后添加一个节点 void addAtTail (int val) LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (cur-next != nullptr) cur = cur-next; cur-next = newNode; _size++; // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 // 如果index小于0，则在头部插入节点 void addAtIndex (int index, int val) if (index _size) return; // index 小于等于零时，添加新的头结点 if (index 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while (index--) cur = cur-next; newNode-next = cur-next; cur-next = newNode; _size++; void deleteAtIndex (int index) if (index = _size || index 0) return; LinkedNode* cur = _dummyHead; while (index--) cur = cur-next; LinkedNode* tmp = cur-next; cur-next = tmp-next; delete tmp; tmp = nullptr; _size--; void printLinkedList () LinkedNode cur = _dummyHead; while (cur-next != nullptr) cout cur-next-val ; cur = cur-next; cout endl; private: int _size; LinkedNode* _dummyHead;; 时间复杂度： 空间复杂度：O(n) 206 翻转链表力扣题目链接(opens new window) 题意：反转一个单链表。 示例: 输入: 1-2-3-4-5-NULL 输出: 5-4-3-2-1-NULL 思路： 直接改变链表 next 指针的指向，可以将链表直接反转，而不用定义一个新的链表。 暂时无法在飞书文档外展示此内容 双指针法class Solution public: ListNode* reverseList (ListNode* head) ListNode* tmp; ListNode* cur = head; ListNode* pre = NULL: while (cur) tmp = cur-next; // 保存 cur 的下一个节点 cur-next = pre; // 反转链表节点指向 pre = cur; cur = tmp; return pre; ; 递归法与双指针法类似的逻辑，当 cur 为空的时候循环结束，不断地将 cur 指向 pre 的过程。 class Solution public: ListNode* reverse (ListNode* pre, ListNode* cur) if (cur == NULL) return pre; ListNode* tmp = cur-next; cur-next = pre; return reverse(cur, tmp); ListNode* reverseList (ListNode* head) // 与双指针法的初始化逻辑一直 // ListNode* cur = head; // ListNode* pre = NULL; return (NULL, head); ; 时间复杂度：O(n) ，需要递归处理链表的每个节点 空间复杂度：O(n) ，递归调用了 n 层栈空间 （未理解）另外一种递归写法：从后往前反转指针指向 class Solution public: ListNode* reverseList (ListNode* head) // 边缘条件判断 if (head == NULL) return NULL; if (head-next = NULL) return head; ListNode* last = reverseList(head-next); head-next-next = head; head-next = NULL; return last; ; 时间复杂度：O(n) 空间复杂度：O(n) 24 两两交换链表中的节点力扣题目链接(opens new window) 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 思路： class Solution public: /** * @param head ListNode类 * @return ListNode类 */ ListNode* reverseList (ListNode* head) ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-next = head; ListNode* cur = dummyHead; // 例子： dummyHead(cur) - 1(tmp) - 2 - 3(tmp1) - 4 - null // dummyHead(cur) - 2 - 1 - 3 - 4 - null while (cur-next != nullptr cur-next-next != nullptr) ListNode* tmp = cur-next; ListNode* tmp1 = tmp-next-next-next; cur-next = tmp-next; cur-next-next = tmp; tmp-next = tmp1; cur = cur-next-next; // cur移动两位，准备下一轮的交换 return dummyHead-next; ; 时间复杂度：O(n) 空间复杂度：O(1) 19 删除链表的倒数第 N 个节点力扣题目链接(opens new window) 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ 思路： 方法一：暴力遍历两次遍历，第一遍历得到链表长度 L；第二次遍历找到第 L-n+1 个节点，然后删除。 class Solution public: ListNode* removeNthFromEnd (ListNode* head, int n) ; 方法二：双指针法链表相交环形链表2.3 哈希表定义哈希表（散列表）是根据关键码的值（key）而直接进行访问的数据结构，提高查找速度。哈希表中的关键码就类似于数组中的下标，因而我们可以通过关键码直接访问数据，如下： 一般哈希表都是用来快速判断一个元素是否出现集合里。 哈希函数哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。 如果 hashCode 得到的数值大于哈希表的大小了，也就是大于tableSize了，怎么办呢？ 此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。 此时问题又来了，哈希表我们刚刚说过，就是一个数组。 如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。 哈希碰撞如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。 一般哈希碰撞有两种解决方法， 拉链法和线性探测法。 拉链法刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了。 （数据规模是dataSize， 哈希表的大小为tableSize） 其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 线性探测法使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。 例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了。如图所示： 常见的三种哈希结构当我们想使用哈希法来解决问题的时候，一般会选择三种数据结构：数组、集合（set）、映射（map） 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。 虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。 这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？ 实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。 总结： 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。 如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！ 242 有效的字母异位词力扣题目链接(opens new window) 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s “anagram”, t “nagaram” 输出: true 示例 2: 输入: s “rat”, t “car” 输出: false 说明: 你可以假设字符串只包含小写字母。 方法一：暴力求解两层 for 循环，同时要记录字符是否重复出现，时间复杂度 O(n^2) 方法二：排序t 是 sss 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 sss 和 ttt 分别排序，看排序后的字符串是否相等即可判断。此外，如果 sss 和 ttt 的长度不同，ttt 必然不是 sss 的异位词。 作者：力扣官方题解 class Solution public: bool isAnagram (string s, string t) if (s.length() != t.length()) return false; sort(s.begin(), s.end()); sort(t.begin(), t.end()); return s == t; ; 时间复杂度：排序的时间复杂度为 O(nlogn) ，比较两个字符串是否相等时间复杂度为 O(n) ，总体时间复杂度为 O(nlogn+n)=O(nlogn) 。 空间复杂度：O(logn) 方法三：哈希表 （需要重点掌握）定义一个 record 数组用来记录字符串 s 中字符出现的次数，需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。 在遍历字符串 s 的时候，只需要将 s[i] - ‘a’ 所在的元素做 +1 操作即可，并不需要记住字符 a 的ASCII，只要求出一个相对数值就可以了。 那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。 那么最后检查一下，record数组如果有的元素不为零，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。 最后如果record数组所有元素都为零，说明字符串s和t是字母异位词，return true。 时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。 class Solution public: bool isAnagram (string s, string t) int record[26] = 0; for (int i = 0; i s.size(); i++) record[s[i] - a]++; // ASCII 码值相减即为下标 for (int i = 0; i t.size(); i++) record[t[i] - a]--; for (int i = 0; i 26; i++) if (record[i] != 0) return false; return true; ; Java 版本 class Solution public boolean isAnagram (String s, String t) int[] record = new int[26]; for (int i = 0; i s.length(); i++) record[s.charAt(i) - a]++; for (int i = 0; i t.length(); i++) record[t.charAt(i) - a]--; for (int count:record) if (count != 0) return false; return true; 349 两个数组的交集力扣题目链接(opens new window) 题意：给定两个数组，编写一个函数来计算它们的交集。 练习本道题目掌握 unordered_set 这一数据结构。 注意：输出结果中每一个元素是唯一的，需要去除重复的元素，可以不考虑输出结果的顺序。 unordered_set：基于哈希表实现，具有常数时间复杂度的查找操作，可以快速确定元素是否存在于集合中。另外它还可以自动去除重复的元素，具有更好的性能。 引用传递参数：如果不使用引用传递参数，而直接传递 vector 对象，会触发一次复制构造函数的调用，将原始 vector 复制一份传递给函数，在处理大型 vector 时会消耗大量的时间和内存。通过引用传递参数，函数可以直接修改原始的 vector 对象，而不需要返回值来传递修改后的结果。 class Solution public: vectorint intersection (vectorint nums1, vectorint nums2) unordered_setint result_set; // 定义无序集合，用于存储两个输入向量的交集 // 使用 nums1.begin() 和 nums1.end() 作为参数传递给 unordered_set 的构造函数 // 这里的 begin() 和 end() 是 vectorint 类型的成员函数， // 用于返回指向 nums1 向量的第一个元素和最后一个元素之后的位置的迭代器。 // nums_set 对象被初始化为包含从 nums1.begin() 到 nums1.end() 范围内的所有唯一元素的无序集合。 unordered_setint nums_set(nums1.begin(), nums1.end()); for (int num : nums2) // 遍历 nums2 中每一个元素，判断当前遍历元素 num 是否在 nums1 中存在 // find() 返回一个迭代器：如何查找元素存在，则返回一个指向该元素的迭代器。 // 否则，返回指向集合尾部的迭代器，通常使用 unordered_set.end() 表示 if (nums_set.find(num) != nums_set.end()) result_set.insert(num); return vectorint(result_set.begin(), result_set.end()); ; 时间复杂度：O(n+m) ，m 是最后将 set 转为 vector 空间复杂度：O(n) 使用数组来做哈希表（条件：元素的值有范围，不能太大） class Solution public: vectorint intersection (vectorint nums1, vectorint nums2) unordered_setint result_set; int hash[1005] = 0; if (int num : nums1) hash[num] = 1; for (int num : nums2) if (hash[num] == 1) result_set.insert(num); return vectorint(result_set.begin(), result_set.end()); ; 202 快乐数力扣题目链接(opens new window) 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 输入：19 输出：true 解释： 1^2 + 9^2 82 8^2 + 2^2 68 6^2 + 8^2 100 1^2 + 0^2 + 0^2 1 分析求和的时候，sum 的值可能会重复出现，所以需要快速判断一个元素是否在集合中，考虑使用哈希法。 class Solution public: // 计算一个数各个位置上数字的平方和 int getSum (int n) int sum = 0; while (n) sum += (n % 10) * (n % 10); n /= 10; return sum; bool isHappy (int n) unordered_setint set; while (1) int sum = getSum(n); if (sum == 1) return true; // 如果该 sum 曾经出现过，说明已经进入了无限循环，立即退出 if (set.find(sum) != set.end()) return false; else set.insert(sum); n = sum; ; 时间复杂度: O(logn) 空间复杂度: O(logn) 两数之和力扣题目链接(opens new window) 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums [2, 7, 11, 15], target 9 因为 nums[0] + nums[1] 2 + 7 9 所以返回 [0, 1] 思路1、暴力求解：两层 for 循环查找，时间复杂度为 O(n^2) 2、map 再来看一下使用数组和set来做哈希法的局限。 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N)O(N) 降低到 O(1)O(1)O(1)。 这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 作者：力扣官方题解 链接：https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。 C++中map，有三种类型： 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(log n) O(log n) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。 class Solution public: vectorint twoSum(vectorint nums, int target) unordered_mapint, int hashtable; for (int i = 0; i nums.size(); i++) // auto 关键字用于自动推断变量的类型 // 通过 auto 关键字，编译器会根据 hashtable.find(target - nums[i]) 返回的类型 // 自动推断 it 的类型为哈希表的迭代器类型，而无需显式地指定其类型。 auto iter = hashtable.find(target - nums[i]); if (iter != hashtable.end()) return iter-second, i hashtable[nums[i]] = i; return ; ; 时间复杂度: O(n) 空间复杂度: O(n) 454 四数相加II力扣题目链接(opens new window) 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。 例如: 输入: A [ 1, 2] B [-2,-1] C [-1, 2] D [ 0, 2] 输出: 2 解释: 两个元组如下: (0, 0, 0, 1) - A[0] + B[0] + C[0] + D[1] 1 + (-2) + (-1) + 2 0 (1, 1, 0, 0) - A[1] + B[1] + C[0] + D[0] 2 + (-1) + (-1) + 0 0 思路与算法 我们可以将四个数组分成两部分，AAA 和 BBB 为一组，CCC 和 DDD 为另外一组。 对于 AAA 和 BBB，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j]A[i]+B[j]A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]A[i]+B[j]A[i]+B[j]，对应的值为 A[i]+B[j]A[i]+B[j]A[i]+B[j] 出现的次数。 对于 CCC 和 DDD，我们同样使用二重循环对它们进行遍历。当遍历到 C[k]+D[l]C[k]+D[l]C[k]+D[l] 时，如果 −(C[k]+D[l])-(C[k]+D[l])−(C[k]+D[l]) 出现在哈希映射中，那么将 −(C[k]+D[l])-(C[k]+D[l])−(C[k]+D[l]) 对应的值累加进答案中。 最终即可得到满足 A[i]+B[j]+C[k]+D[l]0A[i]+B[j]+C[k]+D[l]0A[i]+B[j]+C[k]+D[l]0 的四元组数目。 作者：力扣官方题解 链接：https://leetcode.cn/problems/4sum-ii/solutions/499745/si-shu-xiang-jia-ii-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 class Solution public: int fourSumCount(vectorint nums1, vectorint nums2, vectorint nums3, vectorint nums4) unordered_mapint, int countAB; for (int a : nums1) for (int b : nums2) countAB[a + b]++; int count = 0; for (int c : nums3) for (int d : nums4) if (countAB.find(0 - (c + d)) != countAB.end()) count += countAB[0 - (c + d)]; return count; ; 时间复杂度: O(n^2) 空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2 383 赎金信力扣题目链接(opens new window) 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 注意： 你可以假设两个字符串均只含有小写字母。 canConstruct(“a”, “b”) - false canConstruct(“aa”, “ab”) - false canConstruct(“aa”, “aab”) - true 暴力解法两层 for 循环，不断的寻找 class Solution public: bool canConstruct (string ransomNote, string magazine) for (int i = 0; i magazine.size(); i++) for (int j = 0; j ransomNote.size(); j++) if (magazine[i] == ransomNote[j]) ransomeNote.erase(ransomNote.begin() + j); break; if (ransomNote.length() == 0) return true; return false; ; 时间复杂度: O(n^2) 空间复杂度: O(1) 哈希表题目中说只有小写字母，可以采用空间换时间的哈希策略，用一个长度为 26 的数组来记录 magazine 中字母出现的次数。然后再使用 ransomNote 去验证该数组中是否包含了其所需的所有字母。（相比较于使用 map，在数据量大的时候，map空间消耗更大一些。） class Solution public: bool canConstruct(string ransomNote, string magazine) // 代码随想录 // int record[26] = 0; // if (ransomNote.size() magazine.size()) // return false; // // for (int i = 0; i magazine.size(); i++) // record[magazine[i] - a]++; // // for (int j = 0; j ransomNote.size(); j++) // record[ransomNote[j] - a]--; // if (record[ransomNote[j] - a] 0) // return false; // // // return true; // leetcode 官方题解 if (ransomNote.size() magazine.size()) return false; vectorint cnt(26); // auto 关键字用于自动类型推断 // auto 自动推断并创建一个引用变量 for (auto c : magazine) cnt[c - a]++; for (auto c : ransomNote) cnt[c - a]--; if (cnt[c - a] 0) return false; return true; ; 三数之和力扣题目链接(opens new window) 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 哈希法class Solution public: vectorvectorint threeSum (vectorint nums) ; 排序+双指针四数之和2.4 字符串344 反转字符串力扣题目链接(opens new window) 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,”e”,”l”,”l”,”o”] 输出：[“o”,”l”,”l”,”e”,”h”] 示例 2： 输入：[“H”,”a”,”n”,”n”,”a”,”h”] 输出：[“h”,”a”,”n”,”n”,”a”,”H”] 分析：与之前反转链表的思路一样，使用双指针的方法 暂时无法在飞书文档外展示此内容 class Solution public: void reverseString (vectorchar s) for (int i = 0, j = s.size()-1; i s.size()/2; i++,j--) swap(s[i], s[j]); ; 时间复杂度: O(n) 空间复杂度: O(1) 541 反转字符串II力扣题目链接(opens new window) 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例: 输入: s “abcdefg”, k 2 输出: “bacdfeg” 分析：按照题目意思，反转每个下标从 2k的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串。 class Solution public: string reverseStr(string s, int k) int n = s.length(); for (int i = 0; i n; i += 2 * k) reverse(s.begin() + i, s.begin() + min(i + k, n)); return s; ; 替换数字卡码网题目链接(opens new window) 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。 对于输入字符串 “a5b”，函数应该将其转换为 “anumberb” 输入：一个字符串 s,s 仅包含小写字母和数字字符。 输出：打印一个新的字符串，其中每个数字字符都被替换为了number 样例输入：a1b2c3 样例输出：anumberbnumbercnumber 数据范围：1 s.length 10000。 思路：（java 中的 string 不能修改，本题需要使用额外的辅助空间） 双指针法一步步填充：i 指向新长度的末尾，j 指向旧长度的末尾。 很多数组填充类问题，都是预先给数组扩容到填充的大小，然后在从后向前进行操作。优点： 不用申请新数组。 从后向前填充元素，避免了从前向后填充元素时，要把添加元素之后的所有元素都向后移动的问题。 #include iostreamusing namespace std;// class Solution // ;int main() string s; while (cin s) int count = 0; // 统计数字的个数 int sOldSize = s.size(); for (int i = 0; i sOldSize; i++) if (s[i] = 0 s[i] = 9) count++; // 计算扩充字符串后 s 的大小，然后重构 s s.resize(sOldSize + count * 5); int sNewSize = s.size(); // 从后向前将空格替换为 number for (int i = sNewSize - 1, j = sOldSize - 1; j i; i--, j--) if (s[j] 9 || s[j] 0) s[i] = s[j]; else s[i] = r; s[i - 1] = e; s[i - 2] = b; s[i - 3] = m; s[i - 4] = u; s[i - 5] = n; i -= 5; cout s endl; 时间复杂度：O(n) 空间复杂度：O(1) 双指针题目汇总： 27.移除元素(opens new window) 15.三数之和(opens new window) 18.四数之和(opens new window) 206.翻转链表(opens new window) 142.环形链表II(opens new window) 344.反转字符串(opens new window) 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组。在 C++ 中，提供一个 string 类，该类会提供一个 size 接口，可以用来判断 string 类字符串是否结束。 // 判断字符串是否结束string a = asd;for (int i = 0; i a.size(); i++) vectorchar 和 string 在基本操作上没区别，但 string 会提供更多的字符串的处理接口。 151 反转字符串里的单词力扣题目链接(opens new window) 给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 输入: “the sky is blue” 输出: “blue is sky the” 示例 2： 输入: “ hello world! “ 输出: “world! hello” 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 输入: “a good example” 输出: “example good a” 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 思路： 简单：使用 split 库函数，分隔单词，然后定义新的 string 字符串，最后倒序相加 进阶：（要求不能使用辅助空间，空间复杂度要求为 O(1)） 方法：移除多余空格、将整个字符串反转、将每个单词反转 右旋转字符串实现 strStr()重复的字符串2.5 双指针法2.6 栈与队列GPT 队列（Queue） 原理： 队列是一种先进先出（FIFO，First In First Out）的数据结构，类似于现实生活中排队的场景，先到先服务。 在队列中，元素从队列的一端（称为队尾）添加，从另一端（称为队首）移除。 新的元素总是被添加到队列的末尾，而最老的元素总是在队列的开头。 用法： 队列常用于模拟排队、任务调度、广度优先搜索（BFS）等场景。 实现队列通常有两种方式：基于数组实现的顺序队列和基于链表实现的链式队列。 在C++中，可以使用std::queue模板类来实现队列，其提供了队列的常用操作，如入队、出队、查看队首元素等。 栈（Stack） 原理： 栈是一种后进先出（LIFO，Last In First Out）的数据结构，类似于一摞盘子，最后放上去的盘子最先被取走。 在栈中，元素的添加和删除操作只能在栈顶进行。 新的元素总是被添加到栈顶，而最新添加的元素总是在栈顶，最老的元素在栈底。 用法： 栈常用于递归函数调用、表达式求值、括号匹配、深度优先搜索（DFS）等场景。 实现栈通常有两种方式：基于数组实现的顺序栈和基于链表实现的链式栈。 在C++中，可以使用std::stack模板类来实现栈，其提供了栈的常用操作，如入栈、出栈、查看栈顶元素等。 一些常见的示例： #include iostream#include queueint main() // 创建一个队列 std::queueint q; // 入队操作 q.push(10); q.push(20); q.push(30); // 出队操作 while (!q.empty()) std::cout q.front() ; // 访问队首元素 p.pop(); // 移除队首元素 std::cout std::endl; return 0; 同理：对栈也有类似的操作 push()：入栈操作 empty(): 判断栈内元素是否为空 top(): 访问栈顶元素 pop(): 移除栈顶元素 基础队列是先进先出，栈是先进后出。 C++中stack 是容器么？ 我们使用的stack是属于哪个版本的STL？ 我们使用的STL中stack是如何实现的？ stack 提供迭代器来遍历stack空间么？ 首先大家要知道 栈和队列是STL（C++标准库）里面的两个数据结构。 C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。 那么来介绍一下，三个最为普遍的STL版本： HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。 P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。 SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。 接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。 栈先进后出，如图所示： 栈提供 push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 那么问题来了，STL 中栈是用什么容器实现的？ 从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 我们也可以指定vector为栈的底层实现，初始化语句如下： std::stackint, std::vectorint third; // 使用 vector 为底层容器的栈 队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。 也可以指定list 为起底层实现，初始化queue的语句如下： std::queueint, std::listint third; // 定义以list为底层容器的队列 所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。 2.7 二叉树2.8 回溯算法2.9 贪心算法2.10 动态规划2.11 单调栈2.12 图论3 牛客网4 其他问题ACM模型在 Leetcode 上刷题，采用的是核心代码模型。而很多公司的笔试题和面试题都是 ACM 模型，即需要自己处理数据的输入输出。 练习地址：卡码网KamaCoder 题解地址：GitHub - youngyangyang04kamacoder-solutions: 卡码网题解全集 使用git提交代码：如何在Github上提交PR(pull request) | 代码随想录 5 刷题记录回溯 贪心 分治 动态规划： 647. 回文子串 - 力扣（LeetCode） （2024-4-11 20:31） 5. 最长回文子串 - 力扣（LeetCode）（2024-4-11 20:31） 6 面试高频考点 参考：面试高频算法真题 6.1 排序算法冒泡排序快速排序归并排序堆排序","tags":["leetcode"]},{"title":"sketch recognition","path":"/2023/06/02/sketch-recognition/","content":"1 数据集处理服务器地址：10.1.16.116 数据集目录：homedata1sebasprojectssketch-recognitionresnet152-testdataset 原图 sketch_datatrain 原图训练集（250类别，每个类别72张） sketch_dataval 原图测试集（250类别，每个类别8张） 外部轮廓 sketch_datatrain_external 外轮廓训练集（250类别，每个类别72张） sketch_dataval_external 外轮廓测试集（250类别，每个类别8张） 内部细节 sketch_datatrain_internal 内部细节训练集（250类别，每个类别72张） sketch_dataval_internal 内部细节测试集（250类别，每个类别8张） 2 网络结构 三分支网络，以resnet152为backbone，前两个分支之间做交叉注意力机制学习，然后再和第三个分支进行特征融合。三个分支的输入分别是三个不同的数据集，每个数据集中的图像是1111x1111x1的灰度图（白色背景，黑色线条）。 optim.Adam(model.parameters(), lr=lr)best_acc = 0.0train_steps = len(train_loader)for epoch in range(epochs): model.train() train_loss = 0.0 train_correct_num = 0 train_bar = tqdm(zip(train_external_loader, train_internal_loader, train_loader), file=sys.stdout) for step, (external_data, internal_data, data) in enumerate(train_bar): external_images, external_labels = external_data internal_images, internal_labels = internal_data images, labels = data optimizer.zero_grad() external_images = external_images.to(device) external_labels = external_labels.to(device) internal_images = internal_images.to(device) internal_labels = internal_labels.to(device) images = images.to(device) labels = labels.to(device) external_outputs, internal_outputs, outputs = model(external_images, internal_images, images) _, external_predicted = torch.max(external_outputs, 1) train_correct_num += (external_predicted == external_labels).sum().item() _, internal_predicted = torch.max(internal_outputs, 1) train_correct_num += (internal_predicted == internal_labels).sum().item() _, predicted = torch.max(outputs, 1) train_correct_num += (predicted == labels).sum().item() external_loss = criterion(external_outputs, external_labels) internal_loss = criterion(internal_outputs, internal_labels) loss = criterion(outputs, labels) total_loss = external_loss + internal_loss + loss total_loss.backward() optimizer.step() train_loss += total_loss.item() 3 实验结果"},{"title":"C++","path":"/2023/05/20/C/","content":"1 C++基础：变量、条件、循环、字符串、数组、函数、结构体等 重要：指针和内存管理 书籍：c++ primer 2 数据结构与算法大话数据结构、剑指offer、leetcode 刷题 常见的数据结构：字符串、链表、二叉树、堆、栈、队列、哈希等 常见的算法：查找、排序、动态规划等 3 操作系统进程和线程：原子性、并发、锁等 内存：内存分布、内存调度 4 计算机网络TCPIP协议栈：ARP协议、IP协议、ICMP协议、TCP协议、UDP协议、DNS协议、HTTPHTTPS协议 书籍：tcpip详解 5 设计模式单例、工厂、代理、策略、模板方法 书籍：《大话设计模式》 5 实践 Linux操作系统、shell编程、脚本 编译、调试工具： GNU官方关于gcc和gdb的官方文档。《跟我一起写makefile》 gdb调试《debugging with gdb》 Linux系统编程、多线程编程（线程、资源、信号、同步、互斥、锁等）、 网络编程 书籍： elseb站：程序羊"},{"title":"nerf-slam","path":"/2023/04/27/nerf-slam/","content":"Nerf-SLAM1 配置环境1.1 Ubuntu Clash 终端代理clash 选择节点并调整为 global 模式，在 ~.bashrc 中添加以下内容 export https_proxy=http://127.0.0.1:7890 export http_proxy=http://127.0.0.1:7890 export all_proxy=socks5://127.0.0.1:7890 保存文件，并更新文件 source ~/.bashrc# 测试终端是否代理curl cip.cc# 显示香港的节点，则代表成功 1.2 Install nerf-slam项目地址：ToniRVNeRF-SLAM: NeRF-SLAM: Real-Time Dense Monocular SLAM with Neural Radiance Fields. https://arxiv.org/abs/2210.13641 + Sigma-Fusion: Probabilistic Volumetric Fusion for Dense Monocular SLAM https://arxiv.org/abs/2210.01276 (github.com) 使用 git 拉取项目代码 git clone https://github.com/ToniRV/NeRF-SLAM.git --recurse-submodulesgit submodule update --init --recursive 使用 conda 创建一个虚拟环境，防止污染其他环境 # 创建一个名为 nerf-slam 的虚拟环境conda create -n nerf-slam# 查看所有虚拟环境conda env list# 进入创建的虚拟环境conda activate nerf-slam# install torch (CUDA 11.3)pip install torch==1.12.1+cu113 torchvision==0.13.1+cu113 --extra-index-url https://download.pytorch.org/whl/cu113 使用 pip 安装依赖 pip install -r requirements.txt# 安装第三方库 gtsam 所需的依赖pip install -r ./thirdparty/gtsam/python/requirements.txt 1.3 编译 ngp官方教程：（cmake 版本需要大于 3.22） sudo apt install cmakecmake ./thirdparty/instant-ngp -B build_ngpcmake --build build_ngp --config RelWithDebInfo -j 实操： # nerf-slam 环境下，安装最新版 cmakeconda install cmake# NeRF-SLAM 目录下mkdir build_ngp cd build_ngp# 编译 ngpcmake ../thirdparty/instant-ngp# 报错 1：randr headers not found;install libxrandrsudo apt install libxrandr-dev# 报错 2：Xinerama headers not found; install libxinerama development packagesudo apt install libxinerama-dev# 报错 3：Xcursor headers not found; install libxcursor development packagesudo apt install libxcursor-dev# 报错 4：Could NOT find GLEW (missing: GLEW_INCLUDE_DIRS GLEW_LIBRARIES)sudo apt install libglew-dev# 到这一步基本没问题了cd ..cmake --build build_ngp --config RelWithDebInfo -j 按以上步骤操作，最后运行demo.py会报 pyngp 错误，使用另一个分支解决 报错信息： self.ngp = ngp.Testbed(mode, 0) # NGP can only use device = 0TypeError: __init__(): incompatible constructor arguments. The following argument types are supported: 1. pyngp.Testbed(arg0: pyngp.TestbedMode) 2. pyngp.Testbed(arg0: pyngp.TestbedMode, arg1: str, arg2: str) 3. pyngp.Testbed(arg0: pyngp.TestbedMode, arg1: str, arg2: json) 解决方法： # 删除原 instant-ngpcd thirdpartyrm -rf instant-ngp# 地址：https://github.com/ToniRV/instant-ngp/tree/feature/nerf_slamgit clone https://github.com/ToniRV/instant-ngp.git# 安装依赖sudo apt-get install build-essential git python3-dev python3-pip libopenexr-dev libxi-dev libglfw3-dev libglew-dev libomp-dev libxinerama-dev libxcursor-dev# 更新git submodule update --init --recursive# NeRF-SLAM/mkdir build_ngp cd build_ngp# 编译 ngpcmake ../thirdparty/instant-ngpcd ..cmake --build build_ngp --config RelWithDebInfo -j 1.4 编译 gtsam官方教程： cmake ./thirdparty/gtsam -DGTSAM_BUILD_PYTHON=1 -B build_gtsam cmake --build build_gtsam --config RelWithDebInfo -jcd build_gtsammake python-install 安装 python setup.py install 实操： # 创建编译目录mkdir build_gtsam cd build_gtsam# 编译 gtsamcmake ../thirdparty/gtsam -DGTSAM_BUILD_PYTHON=1# 报错 1：Missing required Boost components = v1.65, please install/upgrade Boost or configure your search paths.# 解决方式 1： 创建 software，下载 boost 1.65.1 压缩包，解压编译安装cd ..mkdir software cd softwarewget https://boostorg.jfrog.io/artifactory/main/release/1.65.1/source/boost_1_65_1.tar.gz# 解决方法 2：直接使用 apt 命令安装conda install boostcmake --build build_gtsam --config RelWithDebInfo -j# 报错 ：ModuleNotFoundError: No module named pyparsingconda install pyparsing# 报错：# 解决：https://github.com/ToniRV/NeRF-SLAM/issues/23# gtsam 安装 （gtsam 4.0.3）cd softwarewget https://github.com/borglab/gtsam/archive/refs/tags/4.1.0.tar.gztar -xzvf 4.1.0.tar.gzcd gtsam-4.1.0mkdir build cd build# 编译，加入参数无TBB编译cmake .. -DGTSAM_BUILD_PYTHON=1 -DGTSAM_PYTHON_VERSION=3.10.11 -DGTSAM_WITH_TBB=OFFmake python-install Install: python setup.py install 增加虚拟内存 # bs 单位：1024*1024*1024=1073741824sudo dd if=/dev/zero of=swapfile bs=1024 count=96000000sudo dd if=/dev/zero of=swapfile bs=1073741824 count=48# 把空间格式化为 swap sudo mkswap /swapfile# 使用创建的 swap 空间chmod 0600 /swapfilesudo swapon /swapfile# 释放空间swapoff -a 1.5 下载样本数据集# 下载数据集./scripts/download_replica_sample.bash# 执行命令python ./examples/slam_demo.py --dataset_dir=./datasets/Replica/office0 --dataset_name=nerf --buffer=100 --slam --parallel_run --img_stride=2 --fusion=nerf --multi_gpu --gui# 报错：AttributeError: type object gtsam.gtsam.Pose3 has no attribute identity. Did you mean: Identity? 也可以更改参数 --fusion=sigma 来运行实现 Sigma-Fusion ，论文地址：https://arxiv.org/abs/2210.01276 1.6 监控 GPU1.7 X11报错信息： 03:47:17 ERROR GLFW error #65544: X11: The DISPLAY environment variable is missing 如果以上配置仍然出现问题，可按对应问题在 Issues 里面寻找解决方案，或者也可以尝试后面第二节给出的配置流程（亲测：Titan X 显存不足，A6000 可以跑） 2 jrpowersNeRF-SLAM2.1 InstalljrpowersNeRF-SLAM: Real-Time Dense Monocular SLAM with Neural Radiance Fields. https://arxiv.org/abs/2210.13641 + Sigma-Fusion: Probabilistic Volumetric Fusion for Dense Monocular SLAM https://arxiv.org/abs/2210.01276 (github.com) Clone repo with submodules: git clone https://github.com/jrpowers/NeRF-SLAM.git --recurse-submodulesgit submodule update --init --recursivecd thirdparty/instant-ngp/ git checkout feature/nerf_slam 2.2 Install CUDA 11.7 and PytorchUse a virtual environment conda create -n nerf-slamconda activate nerf-slam# CUDAconda install -c nvidia/label/cuda-11.7.0 cuda-toolkit# pytorchconda install python==3.7pip install torch==1.13.1+cu117 torchvision==0.14.1+cu117 --extra-index-url https://download.pytorch.org/whl/cu117 2.3 Pip install requirementspip install -r requirements.txtpip install -r ./thirdparty/gtsam/python/requirements.txt 2.4 Compile ngp(cmake3.22)# 原版ngp会报错，该分支解决问题cd thirdparty/instant-ngp/ git checkout feature/nerf_slam# NeRF-SLAM 目录下mkdir build_ngp cd build_ngp# 编译 ngpcmake ../thirdparty/instant-ngpcd ..cmake --build build_ngp --config RelWithDebInfo -j 2.5 Compile gtsam and enable the python wrapper# 创建编译目录mkdir build_gtsam cd build_gtsam# 编译 gtsamcmake ../thirdparty/gtsam -DGTSAM_BUILD_PYTHON=1cd ..cmake --build build_gtsam --config RelWithDebInfo -jcd build_gtsammake python-install 2.6 Run# Installpython setup.py install# Download Sample Data./scripts/download_replica_sample.bash# run the command or run.shpython ./examples/slam_demo.py --dataset_dir=./datasets/Replica/office0 --dataset_name=nerf --buffer=100 --slam --parallel_run --img_stride=2 --fusion=nerf --multi_gpu --gui./run.sh","tags":["slam"]},{"title":"常用命令记录","path":"/2023/04/26/常用命令记录/","content":"1 压缩、解压 tar 参数含义 -c：建立压缩档案 -x：解压 -t：查看内容 -z：有 gzip 属性的 -j：有 bz2 属性的 -Z：有 compress 属性的 -v：显示所有过程 -f：使用档案名字。该参数为最后一个参数，后面只能接档案名字 -O：将文件解开到标准输出 常用压缩和解压命令 压缩： # 将目录里所有 jpg 文件打包成 jpg.tartar -cvf jpg.tar *.jpg# 将目录里所有的 jpg 文件打包成 jpg.tar 后，使用 gzip 压缩，生成 jpg.tar.gztar -czvf jpg.tar.gz *.jpg# 将目录内指定文件打包为 tar.bz2 形式tar -cjvf jpg.tar.bz2 *.jpg 解压： # 解压 tar 包tar -xvf fileName.tar# 解压 *.tar.gz 或者 *.tgztar -xzvf fileName.tar.gz# 解压 tar.bz2tar -xjvf fileName.tar.bz2# 解压 rarunrar e fileName.rar# 解压 zipunzip fileName.zip 参考：(126条消息) linux tar 解压命令总结_Young_2717的博客-CSDN博客","tags":["Linux"]},{"title":"3D Reconstruction","path":"/2023/04/25/3D-Reconstruction/","content":"1 Urban-Scene-Semantic-Segmentationsudo apt update 2 COLMAP"},{"title":"voldor-imu","path":"/2023/04/25/Voldor/","content":"VOLDOR-SLAM: For the times when feature-based or direct methods are not good enough (ICRA 2021) 1 环境配置1.1 VOLDOR-SLAM# envconda create -n voldor python==3.6.9# activateconda activate voldor# install the python dependenciescd slam_py/installpip install -r ./requirements.txt# install OpenCVsudo apt install libopencv-dev# PyOpenGLsudo apt install python-opengl# Ceres: http://ceres-solver.org/installation.htmlwget https://github.com/ceres-solver/ceres-solver/archive/refs/tags/2.1.0.tar.gztar -zxvf 2.1.0.tar.gzmv ceres-solver-2.1.0 ceres-solvercd ceres-solvermkdir build cd buildcmake ..sudo make install -j12# pyDBoW3git clone https://github.com/htkseason/pyDBoW3.git libboost.python wget https://boostorg.jfrog.io/artifactory/main/release/1.68.0/source/boost_1_68_0.tar.gz 在编译安装 pyDBoW3时遇到一些问题，把 build.sh 文件拆分一步步执行，排除错误。 VOLDORslam_pyinstallpyDBoW3srcCMakeLists.txt 中加入 DBoW3 路径 set(DBoW3_DIR /home/data1/sebas/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3/lib/cmake/DBoW3)SET(DBoW3_USE_STATIC_LIBS ON)find_package(DBoW3 REQUIRED) 然后执行在 pyDBoW3build 目录下执行 cmake 命令 sudo cmake -DBUILD_PYTHON3=on \\ -DPYTHON_EXECUTABLE=/usr/bin/python3.6 \\ -DBUILD_STATICALLY_LINKED=OFF \\ -DOpenCV_DIR=/data/zhangjiguang/wzq/projects/VOLDOR/slam_py/install/pyDBoW3/install/opencv3/build \\ -DDBoW3_DIR=/data/zhangjiguang/wzq/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3/build \\ -DDBoW3_INCLUDE_DIRS=/data/zhangjiguang/wzq/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3/src \\ -DCMAKE_BUILD_TYPE=Release ../src # 导入路径的方法：在CMakeLists.txt中更改；或者在命令行设置全局变量 export DBoW3_DIR=/home/data1/sebas/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3export CMAKE_PREFIX_PATH=/home/data1/sebas/projects/VOLDOR/slam_py/install/pyDBoW3/install/DBow3:$CMAKE_PREFIX_PATHexport CMAKE_PREFIX_PATH=/usr/lib/x86_64-linux-gnu:$CMAKE_PREFIX_PATHsudo make -j12 以上命令都执行成功后，在 build 目录下会生成一个 pyDBoW3.so 文件，将其复制到 demo 目录下。 # build vo onlycd slam_py/install python setup_linux_vo.py build_ext -i# build full slam pipelinecd slam_py/install python setup_linux_full.py build_ext -i 1.2 AI-IMU# ai-imuconda create -n ai-imu python==3.6.9# install dependenciespip install matplotlib numpy termcolor scipy navpy# torch# 新版本会报错conda install pytorch==1.12.1 torchvision==0.13.1 torchaudio==0.12.1 cudatoolkit=10.2 -c pytorch# 使用旧版本conda install pytorch torchvision cudatoolkit=10.2 clone the repo and test # clone git clone https://github.com/mbrossar/ai-imu-dr.git# Download reformated pickle format of the 00-11 KITTI IMU raw datawget https://www.dropbox.com/s/ey41xsvfqca30vv/data.zipmkdir ai-imu-dr/resultsunzip data.zip -d ai-imu-drrm data.zip# Download training parameterswget https://www.dropbox.com/s/77kq4s7ziyvsrmi/temp.zipunzip temp.zip -d ai-imu-dr/temprm temp.zip# Test the filterscd ai-imu-dr/srcpython3 main_kitti.py 1.3 Dockerubuntu 安装 docker # 安装sudo apt install docker.io nvidia-docker2# 创建 docker 用户组sudo groupadd docker# 将用户加入 docker 用户组sudo gpasswd -a $username docker# 重启 docker 应用sudo systemctl restart docker# 添加访问和执行权限sudo chmod a+rw /var/run/docker.sock# 更换 docker 默认存储位置及镜像源docker info# 将默认位置的 docker 文件夹复制到新目录sudo mv /var/lib/docker /home/data1/sudo vim /etc/docker/daemon.json# 以下为修改内容 runtimes: nvidia: path: nvidia-container-runtime, runtimeArgs: [] , data-root:/home/data1/docker, registry-mirrors:[ https://hub-mirror.c.163.com/, https://docker.mirrors.ustc.edu.cn/ ]# 重启 docker 服务sudo systemctl daemon-reloadsudo systemctl restart docker# 查看当前文件夹及文件大小sudo du -h --max-depth=1# df 以磁盘分区为单位查看文件系统df -lh# 拉取镜像:https://hub.docker.com/r/nvidia/cuda/tags?page=3name=18docker pull nvidia/cuda:11.4.0-devel-ubuntu18.04# testsudo docker run --rm --gpus all nvidia/cuda:11.4.0-devel-ubuntu18.04 nvidia-smi# -i 控制台交互 -t 支持终端登录 -d 指定容器运行于后台# -v 给容器挂载存储卷，挂载到容器某个目录（前者是宿主机目录，后者是容器目录，中间以:分隔）# -p 端口映射（前者是宿主机目录，后者是容器目录，中间以:分隔，例如 -p 80:80）# -m --memory=[] 指定容器内存上限# --name=[] 指定容器名字# --gpus all 使用宿主机gpu# --rm 容器停止后自动删除容器，常用来测试docker run -itd -v ~/work:/work --name=Ubuntu20.04-CUDA --gpus all nvidia/cuda:11.4.2-cudnn8-devel-ubuntu20.04# Titan Xdocker run --gpus all -itd --privileged=true -p 50097:22 --name voldor-imu \\ -v /home/data1/projects:/home/projects \\ -e DISPLAY=$DISPLAY \\ -e GDK_SCALE \\ -e GDK_DPI_SCALE \\ nvidia/cuda:11.4.0-devel-ubuntu18.04 /bin/bash # A6000docker run --gpus all -itd --privileged=true -p 50097:22 --name voldor-imu \\ -v /data/zhangjiguang/wzq/voldor-imu:/home/voldor-imu \\ -e DISPLAY=$DISPLAY \\ -e GDK_SCALE \\ -e GDK_DPI_SCALE \\ nvidia/cuda:11.4.0-devel-ubuntu18.04 /bin/bash# 查看创建的容器IDdocker ps -a # 进入已创建的容器docker attach [ID]# 设置 root 密码passwd# 配置sshapt updateapt install openssh-server vim wget curl cmake# 设置 ssh 配置文件sudo vim /etc/ssh/sshd_configPort 22PermitRootLogin yes UsePAM no# service ssh restart# connectssh root@10.1.16.116 -X -p 50096# DISPLAYexport DISPLAY=10.1.16.227:0.0echo $DISPLAY# testapt install x11-appsxclock 其他源介绍： 科大镜像：https://docker.mirrors.ustc.edu.cn/ 网易：https://hub-mirror.c.163.com/ 七牛云加速器：https://reg-mirror.qiniu.com Docker中国区官方镜像：https://registry.docker-cn.com 阿里云：https:阿里云镜像服务id.mirror.aliyuncs.com 原文链接：https://blog.csdn.net/m0_37282062/article/details/115770314 1.3.1 docker 换源及存储位置1.3.2 打包发布镜像docker commit 07da voldor-imu:v1# tagdocker tag voldor-imu:v1 wzq11011/voldor-imu:v1# pushdocker push wzq11011/voldor-imu:v1 退出容器但不关闭容器：ctrl+p+q vscode 修改文件提示没有权限，修改文件所有者 # 递归修改文件所有者sudo chown -R sebas projects/# 更改用户组chgrp -R sebas projects/git clone https://github.com/htkseason/VOLDOR.gitgit clone https://github.com/mbrossar/ai-imu-dr.git# python 3.6.9python3# pipapt install python3-pippip3 install --upgrade pip# ceres-solver# http://ceres-solver.org/installation.html#linuxapt install cmake libgoogle-glog-dev libgflags-dev libatlas-base-dev libeigen3-dev libsuitesparse-dev# boost# https://blog.csdn.net/qq_41854911/article/details/119454212apt install libboost-all-devdocker exec -it 07da /bin/bash 2 报错信息记录：2.1 cmake版本问题报错：internal error, please report: running “cmake” failed: cannot create transient scope: DBus error “org.freedesktop.DBus.Error.TimedOut”: [Failed to activate service ‘org.freedesktop.systemd1’: timed out (service_start_timeout25000ms)] 解决： pip uninstall cmakesudo apt install cmake# 然后再重新编译解决 2.2 Boost报错： -- Boost 1.54 found.CMake Error at /usr/lib/cmake/Boost-1.81.0/BoostConfig.cmake:141 (find_package): Could not find a package configuration file provided by boost_python-py36 (requested version 1.81.0) with any of the following names: boost_python-py36Config.cmake boost_python-py36-config.cmake Add the installation prefix of boost_python-py36 to CMAKE_PREFIX_PATH or set boost_python-py36_DIR to a directory containing one of the above files. If boost_python-py36 provides a separate development package or SDK, be sure it has been installed.Call Stack (most recent call first): /usr/lib/cmake/Boost-1.81.0/BoostConfig.cmake:262 (boost_find_component) /usr/share/cmake-3.10/Modules/FindBoost.cmake:242 (find_package) CMakeLists.txt:130 (FIND_PACKAGE) 解决： # 手动下载编译 boostwget https://boostorg.jfrog.io/artifactory/main/release/1.68.0/source/boost_1_68_0.tar.gztar -zxvf boost_1_68_0.tar.gz./bootstrap.sh --with-libraries=all --with-toolset=gcc./b2sudo ./b2 installsudo ldconfig 2.3 opencv执行demo的时候报错 报错信息如下： Exception in thread Thread-29:Traceback (most recent call last): File /usr/lib/python3.6/threading.py, line 916, in _bootstrap_inner self.run() File /usr/lib/python3.6/threading.py, line 864, in run self._target(*self._args, **self._kwargs) File ../slam_py/voldor_slam.py, line 718, in vo_thread cv2.imshow(tmpkf_depth, (self.basefocal*0.04)/self.frames[self.fid_cur_tmpkf].get_scaled_depth())cv2.error: OpenCV(4.7.0) /tmp/pip-install-ftep5xuc/opencv-python_faa811634b06405b915df5c9319b9c00/opencv/modules/highgui/src/window.cpp:1272: error: (-2:Unspecified error) The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Cocoa support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script in function cvShowImage 解决方法 # 查看 opencv-python 版本pip show opencv-python# 安装对应版本的 opencv-contribpip install opencv-contrib-python==4.7.0.72 参考：https://blog.csdn.net/qq_46018888/article/details/121430749 3 论文3.1 VOLDOR-SLAM3.1.1 摘要总结作者提出了一种基于外部密集光流输入的密集间接SLAM系统。扩展了概率视觉里程计模型VOLDOR [Min et al. CVPR’20]，通过引入几何先验来从单目捕获中鲁棒地引导估计，同时无缝地支持立体或RGB-D图像。论文中定制的后端将中间几何估计与管理增量姿态图连接性的自适应优先级方案紧密耦合。利用密集光流方法的最新进展，实现了准确和稳健的相机姿态估计，同时构建了细粒度的全局一致的密集环境地图。我们的开源实现在单个GTX1080Ti GPU上在线运行，速度约为15 FPS。 相关工作部分回顾了间接SLAM、直接SLAM和密集光流方法的相关文献，并指出了它们的优缺点。间接SLAM方法通过稀疏关键点匹配来建立帧间的几何关系，然后通过PnP或BA等算法来估计相机姿态和场景结构。这些方法通常可以实时运行，但是可能受到缺乏纹理、重复结构或退化几何配置等因素的影响。直接SLAM方法通过联合光流估计一致的场景结构和相机姿态来避免关键点匹配，但是这些方法通常对光照变化敏感，需要精确的光度校准，并且需要有足够的纹理区域。密集光流方法通过计算帧间像素级别的运动来提供稠密的几何信息，计算成本高昂，并且可能受到遮挡、运动模糊或低纹理等因素的影响。 3.1.2 使用方法论文中使用的方法是密集间接SLAM，它基于外部密集光流输入来估计相机姿态和场景结构。论文的方法分为两个部分：前端和后端。 前端部分是基于VOLDOR的概率视觉里程计模型，它使用密集光流残差来建立帧间的几何关系，并利用几何先验来从单目、双目或RGB-D图像中恢复相机运动和深度图。前端部分还包括了一个帧对齐模块，用于校正光流估计的误差，并提高深度图的质量。 后端部分是一个定制的位姿图优化模块，它将前端的几何估计与一个自适应的优先级方案紧密耦合，以管理增量位姿图的连接性。后端部分还包括了一个地图重建模块，用于从关键帧的深度图中构建细粒度的全局一致的密集环境地图。 3.1.3 实验部分 实验部分首先介绍了实验的设置和评估指标，包括相机姿态误差、绝对轨迹误差、相对姿态误差和地图重建误差等。 然后在四个数据集上进行了实验，分别是TartanAir、KITTI、EuRoC和TUM RGB-D。这些数据集涵盖了不同的输入模式、场景复杂度和运动模式，以验证论文的方法的通用性和鲁棒性。 接着展示了论文的方法在不同输入模式下的定量结果，包括单目、双目和RGB-D。实验结果表明，论文的方法在所有数据集上都取得了优秀的性能，超过了其他SLAM方法的表现。 最后展示了论文的方法在不同输入模式下的定性结果，包括相机轨迹、深度图和密集地图。实验结果显示，论文的方法能够有效地估计相机姿态和场景结构，并构建细粒度的全局一致的密集环境地图。 3.2 AI-IMU3.2.1 摘要总结论文的主要贡献是提出了一种基于惯性测量单元（IMU）的新颖准确的车辆自定位方法：论文的主要思想是利用卡尔曼滤波器和深度神经网络来动态地调整滤波器的噪声参数。作者在KITTI里程计数据集上进行了实验，证明了该方法仅使用IMU就能准确地估计车辆的三维位置、速度、方向和IMU偏差。其结果在平均平移误差上达到了1.10%，与使用激光雷达或立体视觉的顶级方法相媲美。 3.2.2 论文结构论文使用的方法主要包括以下几个部分： 基于IMU的自定位模型，使用一个非线性状态空间模型来描述车辆的运动状态和IMU的偏差，其中状态变量包括位置、速度、方向、陀螺仪偏差和加速度计偏差。 卡尔曼滤波器，使用一个扩展卡尔曼滤波器（EKF）来根据IMU的测量值对状态变量进行估计和更新，其中测量方程是一个恒等映射。 神经网络，使用一个多层感知机（MLP）来根据IMU的测量值和历史噪声参数来预测当前的噪声参数，包括过程噪声协方差矩阵和测量噪声协方差矩阵。 训练策略，使用一个端到端的训练策略来同时优化EKF和MLP的参数，目标函数是最小化EKF的估计误差和MLP的预测误差。 3.2.3 实验部分 数据集，使用KITTI里程计数据集，该数据集包含了22个序列的车辆运动数据，其中11个序列提供了地面真值1。论文使用了前10个序列作为训练集，后一个序列作为测试集。 评估指标，使用平均平移误差（ATE）和平均方向误差（AOE）来评估定位的准确性。ATE是指估计的轨迹与地面真值之间的欧氏距离的平均值。AOE是指估计的方向与地面真值之间的角度差的平均值。 实现细节，使用PyTorch框架实现了EKF和MLP的模型。EKF的状态维度是15，测量维度是6。MLP有两个隐藏层，每层有64个神经元，激活函数是ReLU。训练时使用Adam优化器，学习率是0.001，批大小是256，训练轮数是1000。 结果分析，使用不同的方法在测试集上进行了定位，并与其他基于激光雷达或立体视觉的方法进行了比较。结果显示，论文提出的方法在ATE上达到了1.10%的误差，在AOE上达到了0.33°的误差。这些结果优于其他仅使用IMU的方法，并且与使用其他传感器的方法相当或更好。 3.2.4 代码部分仅使用惯性测量单元在 KITTI 里程计数据集上的平移误差位 1.10% main_kitti.py 导入必要的模块和库 class KITTIParameters 定义KITTI数据集参数和类 class KITTIDataset 读取KITTI数据集文件并处理 def test_filter 定义测试滤波器 def launch(args) 程序入口，通过调节read_data的值，来选择是否读数据集。train_filter、test_filter、results_filter train_filter() test_filter() results_filter() 卡尔曼滤波是一种用于估计系统状态的递归滤波器， 4 光流与IMU结合 AI-IMU：对IMU数据进行预处理，得到初始的相机姿态和场景结构的估计，以及IMU偏差的自校准。 VOLDOR：对密集光流数据进行处理，得到帧间的几何关系和深度图，以及帧对齐的校正。 将AI-IMU方法和论文的方法的输出作为位姿图优化模块的输入，利用自适应优先级方案来管理增量位姿图的连接性，并进行全局优化。 使用地图重建模块对关键帧的深度图进行融合，得到细粒度的全局一致的密集环境地图。","tags":["voldor"]},{"title":"Blog Hexo","path":"/2023/04/25/Blog-Hexo/","content":"记录使用 hexo + github pages 搭建个人博客的步骤 1 Hexo 搭建1.1 Macbook ClashX 终端代理export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 1.2 安装 Homebrew/bin/bash -c $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh) 1.3 安装 node.js、gitbrew install node git 1.4 安装 Hexonpm install -g hexo-cli 1.5 初始化项目在 Documents 目录下创建一个 blog 文件夹，使用 hexo 命令初始化 # ~/Documentshexo init blog# 将 hexo 编译生成 HTML 代码hexo generate # 简化命令：hexo g# 在本地运行hexo serve # 简化命令：hexo s# 安装远程部署插件npm install hexo-deployer-git --save# 远程部署hexo deploy # 简化命令：hexo d 远程部署到 Github Pages 需要更改根目录（~Documentsblog）下的 _config.yml 文件 # Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:wzq11011/wzq11011.github.io.git branch: master 这个地方会报错，需要将本地 git 公钥添加到 github 中。 1.6 同步源码以上的部署只是将 blogpublic 目录下的所有内容上传到 master 分支上，它们实际上是 hexo 编译生成的静态文件。如果要同步博客源码，可以新建一个 hexo 分支，使用 git 命令同步上传所有源码。 Git 基本使用：Git 基本操作 | 菜鸟教程 (runoob.com) # 一个简单的操作流程git init # 初始化仓库git add . # 添加文件到暂存区git commit -m 描述 # 将暂存区内容添加到仓库，并添加描述git status # 查看当前仓库状态，显示有变更的文件git diff # 比较文件的不同，即暂存区和工作区的差异git reset # 回退版本git rm # 将文件从暂存区和工作区删除git mv\t# 移动或重命名工作区文件git remote\t# 查看当前的远程仓库git remote add # 添加远程仓库git clone # clone 一个仓库git pull/fetch # 拉取仓库git push # 上传本地代码到远程仓库 Git 分支管理 # git 命令# 创建分支git branch (branchname)# 删除分支git branch -d (branchname)# 切换分支git checkout (branchname)# 合并分支git merge# 查看日志git log 博客源码上传参考以下指令： git initgit checkout -b hexogit add -A # 添加文件到暂存区git commit -m init blog # 将暂存区内容添加到本地仓库，并添加描述“初始化”# git remote add origin git@github.com:username/username.github.io.gitgit remote add origin git@github.com:wzq11011/wzq11011.github.io.git # 创建远程仓库 origingit push origin hexo # 推送代码到 hexo 分支 报错：这是因为在 themes 文件夹下使用 git 命令拉取的 next 主题，关联了其他作者的 git 仓库，所以 next 文件夹下的内容会无法提交到远程仓库，报错信息提示是否将其作为子模块提交，这里提供不作为子模块提交的解决办法。 hint: Youve added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: the embedded repository and will not know how to obtain it.hint: If you meant to add a submodule, use:hint: hint: git submodule add url themes/nexthint: hint: If you added this path by mistake, you can remove it from thehint: index with:hint: hint: git rm --cached themes/nexthint: hint: See git help submodule for more information. 解决办法： # 从暂存区删除该文件夹git rm --cached themes/next# 查看当前状态git status# 删除 next 文件夹下 .git 文件夹cd themes/nextrm -rf .git# 重新添加 next 文件夹到缓存区git add themes/next/# git commit -m add next# 推送代码到远程仓库git push origin hexo 1.7 多设备同步在新设备上拉取博客源码并安装必要的插件 git clone https://github.com/wzq11011/wzq11011.github.io.gitcd wzq11011.github.io npm install # 然后执行脚本，生成部署博客，同步源码到仓库sh deploy.sh 如果在同步仓库时出现权限不足的问题，需要将本机公钥添加到 github 中 问题描述： : Permission denied (publickey) 解决方法： # 1 验证邮箱与 github 注册邮箱是否一致git config --global --list# 2 设置全局用户名和邮箱git config --global user.name your namegit config --global user.email your email# 3 生成密钥ssh-keygen -t rsa -C your email# 4 将 rsa.pub 公钥内容添加到 github # 5 测试ssh -T git@github.com 1.8 配置站点信息修改根目录下的 _config.yml 文件，在 Site 区域，自定义站点标题、副标题、描述、关键词、作者等 # Sitetitle: CodeCodasubtitle: 宝剑锋从磨砺出，梅花香自苦寒来description: keywords:author: wzq11011language: zh-CN # entimezone: 1.9 修改主题在 Hexo 官网可以查看更多主题。 更改主题为 Next ，Github地址：theme-nexthexo-theme-next: Elegant and powerful theme for Hexo. (github.com) # 也可以在 github 上下载压缩文件，解压到 blog/themes/ 目录下，解压后重命名为 nextgit clone https://github.com/theme-next/hexo-theme-next themes/next# 修改根目录下的 _config.yml 文件，找到 theme 字样，修改为 next。theme: next 2 Hexo 优化2.1 更改主题样式在 blog/themes/next/_config.yml 中更改 Next 主题样式为 Pisces # ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 2.2 Favicon自定义站点标签栏小图标，默认使用 Hexo 小图标，可以上传图片定制小图标，下载图标保存在 themesnextsourceimages 目录下 favicon: small: /images/favicon-16x16.png medium: /images/favicon-32x32.png apple_touch_icon: /images/apple-touch-icon.png safari_pinned_tab: /images/logo.svg # android_manifest: /images/manifest.json # ms_browserconfig: /images/browserconfig.xml 2.3 Code更改代码块的颜色为黑色，并把复制按钮的样式改为类似 Mac 的样式，修改 _config.yml 文件 codeblock: # Code Highlight theme # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic # See: https://github.com/chriskempson/tomorrow-theme highlight_theme: night # Add copy button on codeblock copy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: mac 2.4 评论系统注册一个 OAuth Application，链接为 New OAuth Application (github.com) Homepage URL 和 Authorization callback URL 填博客主域名，拿到 Client ID、Client Secret ，然后在 _config.yml 中更改对应参数即可。 在 blogthemesnext_config.yml 中，补充 active 参数为 gitalk # Multiple Comment System Supportcomments: # Available values: tabs | buttons style: tabs # Choose a comment system to be displayed by default. # Available values: changyan | disqus | disqusjs | gitalk | livere | valine active: gitalk # Setting `true` means remembering the comment system selected by the visitor. storage: true # Lazyload all comment systems. lazyload: false # Modify texts or order for any navs, here are some examples. nav: #disqus: # text: Load Disqus # order: -1 #gitalk: # order: -2 然后再 gitalk 区域填写各项参数 # Gitalk# For more information: https://gitalk.github.io, https://github.com/gitalk/gitalkgitalk: enable: true github_id: wzq11011 # repo: wzq11011.github.io # Repository name to store issues client_id: your client_id # Github Application Client ID client_secret: your client_secret # Github Application Client Secret admin_user: wzq11011 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues distraction_free_mode: true # Facebook-like distraction free mode # Gitalks display language depends on users browser or system environment # If you want everyone visiting your site to see a uniform language, you can set a force language value # Available values: en | es-ES | fr | ru | zh-CN | zh-TW language: zh-CN 2.5 othertop:浏览网页时，快速返回到网站上端，修改 _config.yml 的 back2top 字段 back2top: enable: true # Back to top in sidebar. sidebar: true # Scroll percent label in b2t button. scrollpercent: true Reading_process：阅读进度，sidebar——是否显示侧栏，scrollpercent——显示阅读百分比 # Reading progress barreading_progress: enable: false # Available values: top | bottom position: top color: #37c6c0 height: 3px Bookmark：书签，可根据阅读历史记录，定位上次位置 # Bookmark Supportbookmark: enable: true # Customize the color of the bookmark. color: #222 # If auto, save the reading progress when closing the page or clicking the bookmark-icon. # If manual, only save it by clicking the bookmark-icon. save: auto Github_banner：github 链接 # `Follow me on GitHub` banner in the top-right corner.github_banner: enable: true permalink: https://github.com/wzq11011 title: Follow me on GitHub Pangu：中英文之间留空 math：数学公式显示 pjax： 2.6 标签页、分类页、搜索页3 Hexo 插件记录3.13.23.33.4 代码高亮3.5 在线编写1 Hexo Editor 2 Hexo Admin 4 多终端同步注意：username.github.io 存放的是 hexo 生成的静态文件，用于展示博客内容；HexoBlog 仓库用于存放博客源码，可设置其为私人仓库。 新设备只需要克隆博客源码，然后重新配置一遍 hexo 运行环境就可以继续写博客了。 5 定时更新博客目标：通过脚本定时生成博客、部署博客、同步博客源码 工具：crontab 介绍：crontab 是一个用于定期执行任务（cron jobs）的工具，它允许用户按照设定的时间间隔自动运行命令或脚本。 示例：每天晚上12点自动更新博客 创建 deploy_blog.sh #!/bin/bash# 生成静态博客文件并部署到 GitHubhexo clean hexo g hexo d# 推送代码到远程博客源码仓库git add .git commit -m update $(date +%Y-%m-%d %H:%M:%S)git push origin master 给脚本可执行权限 chmod +x deploy_blog.sh 设置 Cron 作业 # 查看当前用户的所有 cron 作业crontab -l# 在当前命令行环境设置编辑器为 vimexport EDITOR=vim# 写入 bashrc ，设置 vim 为默认编辑器echo export EDITOR=vim ~/.bashrcsource ~/.bashrc# 编辑当前用户的 cron 作业crontab -e# 添加以下内容0 0 * * * /path/to/your/deploy_blog.sh /path/to/your/deploy_log.txt 21 解释： 0 0 * * *: 每天凌晨00:00执行。 /path/to/your/deploy_blog.sh: 替换为你的脚本的实际路径。 /path/to/your/deploy_log.txt 21: 将标准输出和标准错误重定向到日志文件，方便调试。 Crontab 时间格式：Cron 表达式由五部分组成，分别代表分钟、小时、日、月和星期几。每个部分的取值范围如下： 分钟（0-59） 小时（0-23） 日（1-31） 月（1-12） 星期几（0-7），其中 0 和 7 都表示星期日 例如： * * * * *：每分钟执行一次。 0 0 * * *：每天凌晨0点执行。 0 0 * * 1：每周一凌晨0点执行。 */10 * * * *：每隔10分钟执行一次。 参考 如何在 GitHub 上写博客？ - 知乎 (zhihu.com) hexo插件推荐 - 给力经验分享 (glwsq.cn) 使用Hexo + GitHub Pages搭建个人博客站点 | 朝花夕拾 (shipengx.com) 通义千问 未完待续！","tags":["Hexo","Blog"],"categories":["Hexo","Blog"]},{"title":"about","path":"/about/index.html","content":""},{"title":"categories","path":"/categories/index.html","content":""},{"title":"tags","path":"/tags/index.html","content":""},{"path":"/lib/pjax/CHANGELOG.html","content":"0.2.8 - 2019-03-09 Fixed: Edge form support.(#178 - @robinnorth) Fixed: Removed keyup event listener for forms.(#184 - @BehindTheMath) Fixed: Bugs in evalScripts().(#186 - @BehindTheMath) Fixed: Handle non-string HTML passed to loadContent().(#200 - @BehindTheMath) Tooling: Switch linting to ESLint and Prettier.(#191 - @BehindTheMath) 0.2.7 - 2018-08-15 Fixed: Parsing values of option elements in forms.(#162 - @BehindTheMath) Fixed: Added index.d.ts to package.json so it will be installed by npm.(c589ab9 - @BehindTheMath) Fixed: options.history to correctly parse being set to false.(#165 - @BehindTheMath). Fixed: Pass the current options object to loadContent().(#171 - @BehindTheMath) Fixed: Ensure correct XHR encoding for multipartform-data forms(#174 - @BehindTheMath) Added: More documentation.(#160, #171 - @robinnorth, @BehindTheMath) 0.2.6 - 2018-04-30 Fixed: Form submission for GET requests.(#129 - @robinnorth) Fixed: Refactor loadUrl() to make manually calling simpler.(#134 - @robinnorth) Fixed: Support multiple select fields in form submissions.(#147 - @robinnorth) Fixed: Use the same options object in handle-response as in send-request. This way, pjax.state.options will also have the request options.(#148 - @BehindTheMath) Added: Move the XHR callback to a separate method, and trigger an error event if the response cannot be parsed.(#137 - @BehindTheMath) Added: TypeScript definitions.(#138 - @BehindTheMath) Added: replaceNode switch, as an alternative to the outerHTML switch.(#141 - @BehindTheMath) Added: X-PJAX-Selectors HTTP header. This is a serialized JSON array of selectors, taken from options.selectors. You can use this to send back only the elements that Pjax will use to switch, instead of sending the whole page.(#144 - @BehindTheMath) Added: An option to use FormData to submit forms.(#153 - @BehindTheMath) Added: Tests.(f98f2dd, #145 - @robinnorth, @BehindTheMath) 0.2.5 - 2018-02-02 Fixed: Async switch functions now work correctly, because the DOM is now parsed after all the switches finish.(#79, #110 - @oskarrough, @BehindTheMath, @robinnorth) Fixed: Bug on IE11 preventing AJAX page refresh.(#81 - @CPTechnikVX) Fixed: Default switches are now available as Pjax.switches.(#92 - @BehindTheMath) Fixed: An error that was caused by a missing switchElementsAlt.(#93, #104 - @BehindTheMath, @robinnorth) Fixed: Incorrect main field in npm package(#105 - @robinnorth) Fixed: A pending XHR is now aborted if the user navigates somewhere else before the request is finished.(#114 - @robinnorth) Fixed: When rendering new content, focus will now be removed only from elements within one of the containers manipulated by Pjax.(#116 - @BehindTheMath) Fixed: Stop dispatching extraneous pjax:complete events when external scripts load(#118 - @robinnorth) Added: Send the X-PJAX header with XHR requests.(#80 - @bram1028) Added: Direct download link for script tags. (@MoOx) Added: Pass the element that triggered Pjax to the pjax:send event.(#94 - @BehindTheMath) Added: An option to set a timeout for XHR requests.(#95 - @BehindTheMath) Added: Checks for XHR redirects(#101 - @BehindTheMath) Added: Save scroll position with history, and restore when navigating backwards or forwards.(#110, #119 - @BehindTheMath, @robinnorth) Added: Scroll to element position when URL contains a hash(#110 - @BehindTheMath) Added: Minified version of the Pjax bundle.(#115 - @BehindTheMath) Changed: Miscellaneous code and tests cleanup.(#96, #98, #99, #100, #107, #113, #120 - @BehindTheMath, @MoOx, @robinnorth) 0.2.4 - 2016-06-28 Fixed: refresh should now work (use this.parseDOM for refresh)(#67 - @compressed) Fixed: Some attributes, such as itemscope have no corresponding value.This change allows them to still be set.(#67 - @compressed) Added: cacheBust option(#71 - @tremby) 0.2.3 - 2016-03-24 Fixed: currentUrlFullReload option now works Fixed: this.reload is now a Function(#65) 0.2.2 - 2016-03-12 Fixed: added back standalone version in ./pjax.js(#57 Fixed: error when using pjax with google analytics (options was undefined)(#59) Fixed: HierarchyRequestError error(#49) Fixed: TypeError: Pjax.forEachEls is not a function(#52) Fixed: TypeError: Pjax.executeScripts is not a function(#52) Fixed: TypeError: Pjax.clone is not a function(#52) Added: Ignore events with prevented defaults(#50) 0.2.1 - 2015-02-04 Fixed: it’s better when a release have actual files. 0.2.0 - 2015-02-04 Fixed: prevent scrollTo from being converted from false to 0 (#33) Changed: code exploded in commonjs style Added: lots of tests Added: refresh method to force update a DOM element (#36) 0.1.4 - 2014-10-14 Fixed: allow to load pages without any attributes on html element (fix #6) Fixed: make Pjax.switches.sideBySide method usable (fix #13) 0.1.3 - 2014-09-16 Fixed: clicking on the current url somewhere does not produce a full reload by default (see option currentUrlFullReload) Fixed: document.implementation.createHTMLDocument error (in IE10, ref #16) 0.1.2 - 2014-04-03 Changed: pjax.js relocated in src/ Fixed: html attributes of pjaxified document are now available 0.1.1 - 2014-04-02 Fixed: safer UMD wrapper (fix concat issue) 0.1.0 - 2014-03-24✨ Initial release"},{"path":"/lib/pjax/example/forms.html","content":"Forms Forms Hello. Try out the examples below and inspect the results in your browser's developer tools, or go to the Index. GET form Text input: Number input: Email input: Textarea: This is some text Radio input: Radio input alt: Checkbox input: Select list: Option 1 Option 2 POST form Text input: Number input: Email input: Textarea: This is some text Radio input: Radio input alt: Checkbox input: Select list: Option 1 Option 2"},{"path":"/lib/pjax/example/index.html","content":"Hello Index Hello. Go to Page 2 or Page 3 and view your console to see Pjax events. Clicking on this page will do nothing. Manual URL loading You can use Pjax's loadUrl method to manually load a URL. Click the buttons below to try it out! loadUrl with current options loadUrl with overridden options (no cache busting) Forms You can submit GET or POST forms with Pjax! Go to the form examples to try it out."},{"path":"/lib/pjax/example/page2.html","content":"Page 2 Page 2 Hello. Go to Index."},{"path":"/lib/pjax/example/page3.html","content":"Page 3 Page 3 Hello. Go to Index."}]